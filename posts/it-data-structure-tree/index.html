<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="[자료구조] 트리" /><meta name="author" content="dapin1490" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="참고자료 &lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 8 트리 트리의 개념 트리는 계층적인 자료구조. 인공지능 문제에서는 결정 트리에 사용됨. 용어 정리 노드(node) : 트리에 존재하는 각 지점들 루트 노드(root node) : 트리 최상단에 있는 노드 서브트리(subtree) : 루트 노드 아래에 있는 노드들 간선(edge, 에지) : 노드의 연결선 부모 노드(parent node) : 어떤 노드의 바로 위에 연결된 노드 자식 노드(children node) : 어떤 노드의 바로 아래에 연결된 노드 형제 관계(sibling) : 같은 부모 노드를 갖는 자식 노드들 간의 관계 조상 노드(ancestor node) : 루트 노드에서 어떤 노드까지의 경로를 이루는 노드들 자손 노드(descendent node) : 어떤 노드 아래에 연결된 모든 노드 단말 노드(terminal node, leaf node) : 자식 노드가 없는 노드 비단말 노드(nonterminal node) : 자식 노드가 존재하는 노드, 단말 노드의 반대 차수(degree) : 어떤 노드가 갖는 자식 노드의 개수 트리의 차수 : 트리가 갖는 노드들의 차수 중 가장 큰 값 레벨(level) : 트리의 각 층에 번호를 매기는 것, 루트 노드에서 1부터 셈 트리의 높이(height) : 트리가 갖는 최대 레벨 포리스트(forest) : 트리의 집합 트리의 표현 가장 일반적인 방법은 노드 구조를 이용하는 것. 연결 리스트와 유사하며 각 노드는 데이터 필드와 링크 필드를 갖는다. 링크 필드의 개수는 자식 노드의 수와 같다. 실제로 구현할 때는 링크 필드의 수가 일정하지 않으면 구조가 복잡해지므로 이진트리를 많이 사용함. 이 책에서는 이진트리만 다룬다. 이진트리 소개 이진트리란? 모든 노드가 2개의 서브트리를 갖는 트리, 서브트리는 공집합일 수 있다. 모든 노드는 최대 2개의 자식만을 가질 수 있으며 왼쪽과 오른쪽이 구분되어야 한다. 이진트리의 성질 노드 n개 → 간선 (n - 1)개 높이가 h인 이진트리의 노드 수 : h개 이상, (2h - 1)개 이하. 레벨 i에서 노드의 최대 개수는 (2i - 1)개. n개의 노드를 갖는 이진트리의 높이 : ⌈log2(n + 1)⌉ 이상, n 이하 포화 이진트리(full binary tree) : 각 레벨에 노드가 꽉 찬 이진트리. 높이가 k이면 노드는 (2k - 1)개. 각 노드에 번호를 붙일 수 있으며 레벨 단위로 왼쪽에서부터 차례로 붙이면 되고, 항상 일정하게 부여됨. 완전 이진트리(complete binary tree) : 높이가 k인 트리에서 레벨 1부터 (k - 1)까지는 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 순서대로 노드가 채워진 트리. 절대 중간이 비어 있으면 안 되고 노드 번호는 포화 이진트리와 같음. 이진트리의 추상 자료형 트리를 생성하고, 이런저런 정보를 확인하고 삽입, 삭제 등을 수행하는 추상 자료형. 자세한 건 직접 책을 보자. 이진트리의 표현 배열 표현법 저장하고자 하는 이진트리가 완전 이진트리라고 가정, 정해진 높이에 따른 노드 수만큼의 배열을 생성한다. 완전 이진트리의 노드 번호대로 정보를 배열에 저장한다. 주로 포화/완전 이진트리에서 많이 쓰긴 하는데 일반 이진트리도 저장할 수 있다(대신 공간 낭비 심함). 다만 인덱스 0번은 사용하지 않는다. 그게 편하다. 배열의 크기를 변경할 수 없으므로 트리의 높이가 제한되어 많이 사용하지 않음. 링크 표현법 트리의 노드들은 공간적으로는 흩어져 있고, 각각 데이터 필드와 링크 필드를 갖는다. 왼쪽과 오른쪽을 구분한다. 링크 표현법을 이용한 이진트리의 구현 자세한 코드는 생략. 노드 클래스를 먼저 만들고, 그것을 이용해 트리 클래스를 만든다. 노드 클래스는 데이터 필드와 왼쪽, 오른쪽 자식 노드의 링크 필드를 갖고, 트리 클래스는 루트 노드의 포인터만을 멤버 필드로 갖는다. 이진트리의 순회 이진트리의 순회 방법 루트와 서브트리 방문 순서에 따라 구분, 이름은 루트 기준 전위(preorder) : 루트 - 왼쪽 - 오른쪽 중위(inorder) : 왼쪽 - 루트 - 오른쪽 후위(postorder) : 왼쪽 - 오른쪽 - 루트 순회 방법은 자식 노드와 부모 노드의 처리 순서에 따라 다르게 선택한다. 자식 노드를 먼저 봐야 한다면 후위 순회, 부모 노드를 먼저 봐야 한다면 전위 순회. 실제 구현하는 코드는 재귀 호출의 순서만 다를 뿐 큰 구조는 같다. 레벨 순회(level order) 표준 순회 방법은 아니지만 많이 사용한다고 한다. 각 노드를 레벨 순으로 검사하는 방법이다. 앞서 소개한 세 가지 방법은 자료구조로 치면 스택을 사용한 것이고 이 방법은 큐를 사용하는 것이다. 큐에서 노드를 하나 꺼내 방문하고 그 자식들을 큐에 넣어 같은 과정을 반복한다. 자식이 없으면 삽입하지 않고 큐가 빌 때까지 한다. 처음에는 루트 노드를 넣는다. 재귀 호출을 사용하지 않는다. 이진트리 연산 트리의 노드 개수 구하기 모든 노드를 순회하여 개수를 센다. 루트 노드와 양쪽 서브트리의 노드 개수를 합하면 된다. 재귀 호출로 구현한다. 단말 노드 개수 구하기 마찬가지로 모든 노드를 순회하는데, 양쪽 자식이 모두 없는 경우만 센다. 구현은 전체 노드 개수 구하기와 유사하다. 높이 구하기 루트노드에 대해 양쪽 서브트리의 높이를 구하고 그 중 (높은 쪽 + 1)을 결과로 반환한다. 루트 노드도 높이로 셈해야 하기 때문에 서브트리의 높이에 1을 더해야 한다. 재귀 호출로 구현한다. 이 챕터에서 다루는 함수 중 재귀 호출로 구현되는 것 대부분이 실제 사용을 위해 작성되는 함수와 그것을 호출했을 때 실행되는 함수가 메소드 오버로딩으로 서로 다른 인자를 받도록 구현되어 있음에 주의해야 한다. 이진트리 응용 수식 트리 노드가 산술식이나 논리식의 연산자와 피연산자로 이루어진 트리이다. 피연산자는 단말 노드가 되며 연산자는 비단말노드이다. 이 트리는 자식 노드를 먼저 계산하고 부모 노드를 계산해야 하므로 후위 순회를 해야 한다. 디렉터리 용량 계산 지금은 이진트리를 사용하고 있기 때문에 한 폴더에 두 개보다 많은 하위 폴더가 존재하면 안 된다. 서브 디렉터리의 용량을 계산한 후 루트 디렉터리의 용량을 계산해야 하므로 마찬가지로 후위 순회를 사용한다. 스레드 이진트리 목적 : 재귀 호출이나 다른 자료구조의 혼용 없이 순회를 구현하고 싶다. 실현 방안 : 트리에 존재하는 null 링크들(주로 단말 노드에 많음)을 원래 순회 과정에서 다음에 방문해야 할 노드(후속자)에 연결해놓기. 예를 들어 중위 순회이고 B - A - C 순서로 방문해야 한다면 실제 트리 구조상 연결 관계는 B ← A → C인데, 순회 순서에 맞게 B → A 링크를 만들어 둔다는 것. 이때 각 노드에 연결된 링크가 트리의 간선인지 순회를 위한 링크인지 구분하기 위한 필드 변수(bool)가 추가로 필요하다. 순회를 위해 연결하는 링크는 오른쪽 간선을 이용한다. 자세한 코드는 생략한다." /><meta property="og:description" content="참고자료 &lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 8 트리 트리의 개념 트리는 계층적인 자료구조. 인공지능 문제에서는 결정 트리에 사용됨. 용어 정리 노드(node) : 트리에 존재하는 각 지점들 루트 노드(root node) : 트리 최상단에 있는 노드 서브트리(subtree) : 루트 노드 아래에 있는 노드들 간선(edge, 에지) : 노드의 연결선 부모 노드(parent node) : 어떤 노드의 바로 위에 연결된 노드 자식 노드(children node) : 어떤 노드의 바로 아래에 연결된 노드 형제 관계(sibling) : 같은 부모 노드를 갖는 자식 노드들 간의 관계 조상 노드(ancestor node) : 루트 노드에서 어떤 노드까지의 경로를 이루는 노드들 자손 노드(descendent node) : 어떤 노드 아래에 연결된 모든 노드 단말 노드(terminal node, leaf node) : 자식 노드가 없는 노드 비단말 노드(nonterminal node) : 자식 노드가 존재하는 노드, 단말 노드의 반대 차수(degree) : 어떤 노드가 갖는 자식 노드의 개수 트리의 차수 : 트리가 갖는 노드들의 차수 중 가장 큰 값 레벨(level) : 트리의 각 층에 번호를 매기는 것, 루트 노드에서 1부터 셈 트리의 높이(height) : 트리가 갖는 최대 레벨 포리스트(forest) : 트리의 집합 트리의 표현 가장 일반적인 방법은 노드 구조를 이용하는 것. 연결 리스트와 유사하며 각 노드는 데이터 필드와 링크 필드를 갖는다. 링크 필드의 개수는 자식 노드의 수와 같다. 실제로 구현할 때는 링크 필드의 수가 일정하지 않으면 구조가 복잡해지므로 이진트리를 많이 사용함. 이 책에서는 이진트리만 다룬다. 이진트리 소개 이진트리란? 모든 노드가 2개의 서브트리를 갖는 트리, 서브트리는 공집합일 수 있다. 모든 노드는 최대 2개의 자식만을 가질 수 있으며 왼쪽과 오른쪽이 구분되어야 한다. 이진트리의 성질 노드 n개 → 간선 (n - 1)개 높이가 h인 이진트리의 노드 수 : h개 이상, (2h - 1)개 이하. 레벨 i에서 노드의 최대 개수는 (2i - 1)개. n개의 노드를 갖는 이진트리의 높이 : ⌈log2(n + 1)⌉ 이상, n 이하 포화 이진트리(full binary tree) : 각 레벨에 노드가 꽉 찬 이진트리. 높이가 k이면 노드는 (2k - 1)개. 각 노드에 번호를 붙일 수 있으며 레벨 단위로 왼쪽에서부터 차례로 붙이면 되고, 항상 일정하게 부여됨. 완전 이진트리(complete binary tree) : 높이가 k인 트리에서 레벨 1부터 (k - 1)까지는 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 순서대로 노드가 채워진 트리. 절대 중간이 비어 있으면 안 되고 노드 번호는 포화 이진트리와 같음. 이진트리의 추상 자료형 트리를 생성하고, 이런저런 정보를 확인하고 삽입, 삭제 등을 수행하는 추상 자료형. 자세한 건 직접 책을 보자. 이진트리의 표현 배열 표현법 저장하고자 하는 이진트리가 완전 이진트리라고 가정, 정해진 높이에 따른 노드 수만큼의 배열을 생성한다. 완전 이진트리의 노드 번호대로 정보를 배열에 저장한다. 주로 포화/완전 이진트리에서 많이 쓰긴 하는데 일반 이진트리도 저장할 수 있다(대신 공간 낭비 심함). 다만 인덱스 0번은 사용하지 않는다. 그게 편하다. 배열의 크기를 변경할 수 없으므로 트리의 높이가 제한되어 많이 사용하지 않음. 링크 표현법 트리의 노드들은 공간적으로는 흩어져 있고, 각각 데이터 필드와 링크 필드를 갖는다. 왼쪽과 오른쪽을 구분한다. 링크 표현법을 이용한 이진트리의 구현 자세한 코드는 생략. 노드 클래스를 먼저 만들고, 그것을 이용해 트리 클래스를 만든다. 노드 클래스는 데이터 필드와 왼쪽, 오른쪽 자식 노드의 링크 필드를 갖고, 트리 클래스는 루트 노드의 포인터만을 멤버 필드로 갖는다. 이진트리의 순회 이진트리의 순회 방법 루트와 서브트리 방문 순서에 따라 구분, 이름은 루트 기준 전위(preorder) : 루트 - 왼쪽 - 오른쪽 중위(inorder) : 왼쪽 - 루트 - 오른쪽 후위(postorder) : 왼쪽 - 오른쪽 - 루트 순회 방법은 자식 노드와 부모 노드의 처리 순서에 따라 다르게 선택한다. 자식 노드를 먼저 봐야 한다면 후위 순회, 부모 노드를 먼저 봐야 한다면 전위 순회. 실제 구현하는 코드는 재귀 호출의 순서만 다를 뿐 큰 구조는 같다. 레벨 순회(level order) 표준 순회 방법은 아니지만 많이 사용한다고 한다. 각 노드를 레벨 순으로 검사하는 방법이다. 앞서 소개한 세 가지 방법은 자료구조로 치면 스택을 사용한 것이고 이 방법은 큐를 사용하는 것이다. 큐에서 노드를 하나 꺼내 방문하고 그 자식들을 큐에 넣어 같은 과정을 반복한다. 자식이 없으면 삽입하지 않고 큐가 빌 때까지 한다. 처음에는 루트 노드를 넣는다. 재귀 호출을 사용하지 않는다. 이진트리 연산 트리의 노드 개수 구하기 모든 노드를 순회하여 개수를 센다. 루트 노드와 양쪽 서브트리의 노드 개수를 합하면 된다. 재귀 호출로 구현한다. 단말 노드 개수 구하기 마찬가지로 모든 노드를 순회하는데, 양쪽 자식이 모두 없는 경우만 센다. 구현은 전체 노드 개수 구하기와 유사하다. 높이 구하기 루트노드에 대해 양쪽 서브트리의 높이를 구하고 그 중 (높은 쪽 + 1)을 결과로 반환한다. 루트 노드도 높이로 셈해야 하기 때문에 서브트리의 높이에 1을 더해야 한다. 재귀 호출로 구현한다. 이 챕터에서 다루는 함수 중 재귀 호출로 구현되는 것 대부분이 실제 사용을 위해 작성되는 함수와 그것을 호출했을 때 실행되는 함수가 메소드 오버로딩으로 서로 다른 인자를 받도록 구현되어 있음에 주의해야 한다. 이진트리 응용 수식 트리 노드가 산술식이나 논리식의 연산자와 피연산자로 이루어진 트리이다. 피연산자는 단말 노드가 되며 연산자는 비단말노드이다. 이 트리는 자식 노드를 먼저 계산하고 부모 노드를 계산해야 하므로 후위 순회를 해야 한다. 디렉터리 용량 계산 지금은 이진트리를 사용하고 있기 때문에 한 폴더에 두 개보다 많은 하위 폴더가 존재하면 안 된다. 서브 디렉터리의 용량을 계산한 후 루트 디렉터리의 용량을 계산해야 하므로 마찬가지로 후위 순회를 사용한다. 스레드 이진트리 목적 : 재귀 호출이나 다른 자료구조의 혼용 없이 순회를 구현하고 싶다. 실현 방안 : 트리에 존재하는 null 링크들(주로 단말 노드에 많음)을 원래 순회 과정에서 다음에 방문해야 할 노드(후속자)에 연결해놓기. 예를 들어 중위 순회이고 B - A - C 순서로 방문해야 한다면 실제 트리 구조상 연결 관계는 B ← A → C인데, 순회 순서에 맞게 B → A 링크를 만들어 둔다는 것. 이때 각 노드에 연결된 링크가 트리의 간선인지 순회를 위한 링크인지 구분하기 위한 필드 변수(bool)가 추가로 필요하다. 순회를 위해 연결하는 링크는 오른쪽 간선을 이용한다. 자세한 코드는 생략한다." /><link rel="canonical" href="https://dapin1490.github.io/satinbower/posts/it-data-structure-tree/" /><meta property="og:url" content="https://dapin1490.github.io/satinbower/posts/it-data-structure-tree/" /><meta property="og:site_name" content="새틴바우어" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-04T20:05:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[자료구조] 트리" /><meta name="twitter:site" content="@dapin1490" /><meta name="twitter:creator" content="@dapin1490" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dapin1490"},"dateModified":"2022-09-04T20:05:00+09:00","datePublished":"2022-09-04T20:05:00+09:00","description":"참고자료 &lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 8 트리 트리의 개념 트리는 계층적인 자료구조. 인공지능 문제에서는 결정 트리에 사용됨. 용어 정리 노드(node) : 트리에 존재하는 각 지점들 루트 노드(root node) : 트리 최상단에 있는 노드 서브트리(subtree) : 루트 노드 아래에 있는 노드들 간선(edge, 에지) : 노드의 연결선 부모 노드(parent node) : 어떤 노드의 바로 위에 연결된 노드 자식 노드(children node) : 어떤 노드의 바로 아래에 연결된 노드 형제 관계(sibling) : 같은 부모 노드를 갖는 자식 노드들 간의 관계 조상 노드(ancestor node) : 루트 노드에서 어떤 노드까지의 경로를 이루는 노드들 자손 노드(descendent node) : 어떤 노드 아래에 연결된 모든 노드 단말 노드(terminal node, leaf node) : 자식 노드가 없는 노드 비단말 노드(nonterminal node) : 자식 노드가 존재하는 노드, 단말 노드의 반대 차수(degree) : 어떤 노드가 갖는 자식 노드의 개수 트리의 차수 : 트리가 갖는 노드들의 차수 중 가장 큰 값 레벨(level) : 트리의 각 층에 번호를 매기는 것, 루트 노드에서 1부터 셈 트리의 높이(height) : 트리가 갖는 최대 레벨 포리스트(forest) : 트리의 집합 트리의 표현 가장 일반적인 방법은 노드 구조를 이용하는 것. 연결 리스트와 유사하며 각 노드는 데이터 필드와 링크 필드를 갖는다. 링크 필드의 개수는 자식 노드의 수와 같다. 실제로 구현할 때는 링크 필드의 수가 일정하지 않으면 구조가 복잡해지므로 이진트리를 많이 사용함. 이 책에서는 이진트리만 다룬다. 이진트리 소개 이진트리란? 모든 노드가 2개의 서브트리를 갖는 트리, 서브트리는 공집합일 수 있다. 모든 노드는 최대 2개의 자식만을 가질 수 있으며 왼쪽과 오른쪽이 구분되어야 한다. 이진트리의 성질 노드 n개 → 간선 (n - 1)개 높이가 h인 이진트리의 노드 수 : h개 이상, (2h - 1)개 이하. 레벨 i에서 노드의 최대 개수는 (2i - 1)개. n개의 노드를 갖는 이진트리의 높이 : ⌈log2(n + 1)⌉ 이상, n 이하 포화 이진트리(full binary tree) : 각 레벨에 노드가 꽉 찬 이진트리. 높이가 k이면 노드는 (2k - 1)개. 각 노드에 번호를 붙일 수 있으며 레벨 단위로 왼쪽에서부터 차례로 붙이면 되고, 항상 일정하게 부여됨. 완전 이진트리(complete binary tree) : 높이가 k인 트리에서 레벨 1부터 (k - 1)까지는 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 순서대로 노드가 채워진 트리. 절대 중간이 비어 있으면 안 되고 노드 번호는 포화 이진트리와 같음. 이진트리의 추상 자료형 트리를 생성하고, 이런저런 정보를 확인하고 삽입, 삭제 등을 수행하는 추상 자료형. 자세한 건 직접 책을 보자. 이진트리의 표현 배열 표현법 저장하고자 하는 이진트리가 완전 이진트리라고 가정, 정해진 높이에 따른 노드 수만큼의 배열을 생성한다. 완전 이진트리의 노드 번호대로 정보를 배열에 저장한다. 주로 포화/완전 이진트리에서 많이 쓰긴 하는데 일반 이진트리도 저장할 수 있다(대신 공간 낭비 심함). 다만 인덱스 0번은 사용하지 않는다. 그게 편하다. 배열의 크기를 변경할 수 없으므로 트리의 높이가 제한되어 많이 사용하지 않음. 링크 표현법 트리의 노드들은 공간적으로는 흩어져 있고, 각각 데이터 필드와 링크 필드를 갖는다. 왼쪽과 오른쪽을 구분한다. 링크 표현법을 이용한 이진트리의 구현 자세한 코드는 생략. 노드 클래스를 먼저 만들고, 그것을 이용해 트리 클래스를 만든다. 노드 클래스는 데이터 필드와 왼쪽, 오른쪽 자식 노드의 링크 필드를 갖고, 트리 클래스는 루트 노드의 포인터만을 멤버 필드로 갖는다. 이진트리의 순회 이진트리의 순회 방법 루트와 서브트리 방문 순서에 따라 구분, 이름은 루트 기준 전위(preorder) : 루트 - 왼쪽 - 오른쪽 중위(inorder) : 왼쪽 - 루트 - 오른쪽 후위(postorder) : 왼쪽 - 오른쪽 - 루트 순회 방법은 자식 노드와 부모 노드의 처리 순서에 따라 다르게 선택한다. 자식 노드를 먼저 봐야 한다면 후위 순회, 부모 노드를 먼저 봐야 한다면 전위 순회. 실제 구현하는 코드는 재귀 호출의 순서만 다를 뿐 큰 구조는 같다. 레벨 순회(level order) 표준 순회 방법은 아니지만 많이 사용한다고 한다. 각 노드를 레벨 순으로 검사하는 방법이다. 앞서 소개한 세 가지 방법은 자료구조로 치면 스택을 사용한 것이고 이 방법은 큐를 사용하는 것이다. 큐에서 노드를 하나 꺼내 방문하고 그 자식들을 큐에 넣어 같은 과정을 반복한다. 자식이 없으면 삽입하지 않고 큐가 빌 때까지 한다. 처음에는 루트 노드를 넣는다. 재귀 호출을 사용하지 않는다. 이진트리 연산 트리의 노드 개수 구하기 모든 노드를 순회하여 개수를 센다. 루트 노드와 양쪽 서브트리의 노드 개수를 합하면 된다. 재귀 호출로 구현한다. 단말 노드 개수 구하기 마찬가지로 모든 노드를 순회하는데, 양쪽 자식이 모두 없는 경우만 센다. 구현은 전체 노드 개수 구하기와 유사하다. 높이 구하기 루트노드에 대해 양쪽 서브트리의 높이를 구하고 그 중 (높은 쪽 + 1)을 결과로 반환한다. 루트 노드도 높이로 셈해야 하기 때문에 서브트리의 높이에 1을 더해야 한다. 재귀 호출로 구현한다. 이 챕터에서 다루는 함수 중 재귀 호출로 구현되는 것 대부분이 실제 사용을 위해 작성되는 함수와 그것을 호출했을 때 실행되는 함수가 메소드 오버로딩으로 서로 다른 인자를 받도록 구현되어 있음에 주의해야 한다. 이진트리 응용 수식 트리 노드가 산술식이나 논리식의 연산자와 피연산자로 이루어진 트리이다. 피연산자는 단말 노드가 되며 연산자는 비단말노드이다. 이 트리는 자식 노드를 먼저 계산하고 부모 노드를 계산해야 하므로 후위 순회를 해야 한다. 디렉터리 용량 계산 지금은 이진트리를 사용하고 있기 때문에 한 폴더에 두 개보다 많은 하위 폴더가 존재하면 안 된다. 서브 디렉터리의 용량을 계산한 후 루트 디렉터리의 용량을 계산해야 하므로 마찬가지로 후위 순회를 사용한다. 스레드 이진트리 목적 : 재귀 호출이나 다른 자료구조의 혼용 없이 순회를 구현하고 싶다. 실현 방안 : 트리에 존재하는 null 링크들(주로 단말 노드에 많음)을 원래 순회 과정에서 다음에 방문해야 할 노드(후속자)에 연결해놓기. 예를 들어 중위 순회이고 B - A - C 순서로 방문해야 한다면 실제 트리 구조상 연결 관계는 B ← A → C인데, 순회 순서에 맞게 B → A 링크를 만들어 둔다는 것. 이때 각 노드에 연결된 링크가 트리의 간선인지 순회를 위한 링크인지 구분하기 위한 필드 변수(bool)가 추가로 필요하다. 순회를 위해 연결하는 링크는 오른쪽 간선을 이용한다. 자세한 코드는 생략한다.","headline":"[자료구조] 트리","mainEntityOfPage":{"@type":"WebPage","@id":"https://dapin1490.github.io/satinbower/posts/it-data-structure-tree/"},"url":"https://dapin1490.github.io/satinbower/posts/it-data-structure-tree/"}</script><title>[자료구조] 트리 | 새틴바우어</title><link rel="apple-touch-icon" sizes="180x180" href="/satinbower/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/satinbower/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/satinbower/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/satinbower/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/satinbower/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="새틴바우어"><meta name="application-name" content="새틴바우어"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/satinbower/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/satinbower/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/satinbower/" class="mx-auto"> <img src="/satinbower/assets/img/profile_image.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/satinbower/">새틴바우어</a></div><div class="site-subtitle font-italic">dapin1490's hand-made study blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/satinbower/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/satinbower/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/satinbower/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/satinbower/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/satinbower/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dapin1490" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dapin1490" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dapin1490','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/satinbower/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/satinbower/"> 홈 </a> </span> <span>[자료구조] 트리</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[자료구조] 트리</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1662289500" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-09-04 </em> </span><div class="d-flex justify-content-between"> <span> By <em> dapin1490 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2331 단어"> <em>12 분</em>읽는 시간</span></div></div></div><div class="post-content"><p><h2>참고자료</h2>&lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사<br /> 공부 범위 : 챕터 8 트리</p><p><br /></p><p><h2>트리의 개념</h2>트리는 계층적인 자료구조. 인공지능 문제에서는 결정 트리에 사용됨.<br /> <br /><h3>용어 정리</h3><ul><li>노드(node) : 트리에 존재하는 각 지점들<li>루트 노드(root node) : 트리 최상단에 있는 노드<li>서브트리(subtree) : 루트 노드 아래에 있는 노드들<li>간선(edge, 에지) : 노드의 연결선<li>부모 노드(parent node) : 어떤 노드의 바로 위에 연결된 노드<li>자식 노드(children node) : 어떤 노드의 바로 아래에 연결된 노드<li>형제 관계(sibling) : 같은 부모 노드를 갖는 자식 노드들 간의 관계<li>조상 노드(ancestor node) : 루트 노드에서 어떤 노드까지의 경로를 이루는 노드들<li>자손 노드(descendent node) : 어떤 노드 아래에 연결된 모든 노드<li>단말 노드(terminal node, leaf node) : 자식 노드가 없는 노드<li>비단말 노드(nonterminal node) : 자식 노드가 존재하는 노드, 단말 노드의 반대<li>차수(degree) : 어떤 노드가 갖는 자식 노드의 개수<li>트리의 차수 : 트리가 갖는 노드들의 차수 중 가장 큰 값<li>레벨(level) : 트리의 각 층에 번호를 매기는 것, 루트 노드에서 1부터 셈<li>트리의 높이(height) : 트리가 갖는 최대 레벨<li>포리스트(forest) : 트리의 집합</ul><br /><h3>트리의 표현</h3>가장 일반적인 방법은 노드 구조를 이용하는 것. 연결 리스트와 유사하며 각 노드는 데이터 필드와 링크 필드를 갖는다. 링크 필드의 개수는 자식 노드의 수와 같다. 실제로 구현할 때는 링크 필드의 수가 일정하지 않으면 구조가 복잡해지므로 이진트리를 많이 사용함. 이 책에서는 이진트리만 다룬다.</p><p><br /></p><p><h2>이진트리 소개</h2><h3>이진트리란?</h3>모든 노드가 2개의 서브트리를 갖는 트리, 서브트리는 공집합일 수 있다. 모든 노드는 최대 2개의 자식만을 가질 수 있으며 왼쪽과 오른쪽이 구분되어야 한다.<br /> <br /><h3>이진트리의 성질</h3><ul><li>노드 n개 → 간선 (n - 1)개<li>높이가 h인 이진트리의 노드 수 : h개 이상, (2<sup>h</sup> - 1)개 이하. 레벨 i에서 노드의 최대 개수는 (2<sup>i</sup> - 1)개.<li>n개의 노드를 갖는 이진트리의 높이 : ⌈log<sub>2</sub>(n + 1)⌉ 이상, n 이하<li>포화 이진트리(full binary tree) : 각 레벨에 노드가 꽉 찬 이진트리. 높이가 k이면 노드는 (2<sup>k</sup> - 1)개. 각 노드에 번호를 붙일 수 있으며 레벨 단위로 왼쪽에서부터 차례로 붙이면 되고, 항상 일정하게 부여됨.<li>완전 이진트리(complete binary tree) : 높이가 k인 트리에서 레벨 1부터 (k - 1)까지는 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 순서대로 노드가 채워진 트리. 절대 중간이 비어 있으면 안 되고 노드 번호는 포화 이진트리와 같음.</ul><br /><h3>이진트리의 추상 자료형</h3>트리를 생성하고, 이런저런 정보를 확인하고 삽입, 삭제 등을 수행하는 추상 자료형. 자세한 건 직접 책을 보자.</p><p><br /></p><p><h2>이진트리의 표현</h2><h3>배열 표현법</h3>저장하고자 하는 이진트리가 완전 이진트리라고 가정, 정해진 높이에 따른 노드 수만큼의 배열을 생성한다. 완전 이진트리의 노드 번호대로 정보를 배열에 저장한다. 주로 포화/완전 이진트리에서 많이 쓰긴 하는데 일반 이진트리도 저장할 수 있다(대신 공간 낭비 심함). 다만 인덱스 0번은 사용하지 않는다. 그게 편하다. 배열의 크기를 변경할 수 없으므로 트리의 높이가 제한되어 많이 사용하지 않음.<br /> <br /><h3>링크 표현법</h3>트리의 노드들은 공간적으로는 흩어져 있고, 각각 데이터 필드와 링크 필드를 갖는다. 왼쪽과 오른쪽을 구분한다.</p><p><br /></p><p><h2>링크 표현법을 이용한 이진트리의 구현</h2>자세한 코드는 생략. 노드 클래스를 먼저 만들고, 그것을 이용해 트리 클래스를 만든다. 노드 클래스는 데이터 필드와 왼쪽, 오른쪽 자식 노드의 링크 필드를 갖고, 트리 클래스는 루트 노드의 포인터만을 멤버 필드로 갖는다.</p><p><br /></p><p><h2>이진트리의 순회</h2><h3>이진트리의 순회 방법</h3>루트와 서브트리 방문 순서에 따라 구분, 이름은 루트 기준<ul><li>전위(preorder) : 루트 - 왼쪽 - 오른쪽<li>중위(inorder) : 왼쪽 - 루트 - 오른쪽<li>후위(postorder) : 왼쪽 - 오른쪽 - 루트</ul>순회 방법은 자식 노드와 부모 노드의 처리 순서에 따라 다르게 선택한다. 자식 노드를 먼저 봐야 한다면 후위 순회, 부모 노드를 먼저 봐야 한다면 전위 순회. 실제 구현하는 코드는 재귀 호출의 순서만 다를 뿐 큰 구조는 같다.<br /> <br /><h3>레벨 순회(level order)</h3>표준 순회 방법은 아니지만 많이 사용한다고 한다. 각 노드를 레벨 순으로 검사하는 방법이다. 앞서 소개한 세 가지 방법은 자료구조로 치면 스택을 사용한 것이고 이 방법은 큐를 사용하는 것이다.<br /> 큐에서 노드를 하나 꺼내 방문하고 그 자식들을 큐에 넣어 같은 과정을 반복한다. 자식이 없으면 삽입하지 않고 큐가 빌 때까지 한다. 처음에는 루트 노드를 넣는다. <strong>재귀 호출을 사용하지 않는다.</strong></p><p><br /></p><p><h2>이진트리 연산</h2><h3>트리의 노드 개수 구하기</h3>모든 노드를 순회하여 개수를 센다. 루트 노드와 양쪽 서브트리의 노드 개수를 합하면 된다. 재귀 호출로 구현한다.<br /> <br /><h3>단말 노드 개수 구하기</h3>마찬가지로 모든 노드를 순회하는데, 양쪽 자식이 모두 없는 경우만 센다. 구현은 전체 노드 개수 구하기와 유사하다.<br /> <br /><h3>높이 구하기</h3>루트노드에 대해 양쪽 서브트리의 높이를 구하고 그 중 (높은 쪽 + 1)을 결과로 반환한다. 루트 노드도 높이로 셈해야 하기 때문에 서브트리의 높이에 1을 더해야 한다. 재귀 호출로 구현한다. 이 챕터에서 다루는 함수 중 재귀 호출로 구현되는 것 대부분이 실제 사용을 위해 작성되는 함수와 그것을 호출했을 때 실행되는 함수가 메소드 오버로딩으로 서로 다른 인자를 받도록 구현되어 있음에 주의해야 한다.</p><p><br /></p><p><h2>이진트리 응용</h2><h3>수식 트리</h3>노드가 산술식이나 논리식의 연산자와 피연산자로 이루어진 트리이다. 피연산자는 단말 노드가 되며 연산자는 비단말노드이다. 이 트리는 자식 노드를 먼저 계산하고 부모 노드를 계산해야 하므로 후위 순회를 해야 한다.<br /> <br /><h3>디렉터리 용량 계산</h3>지금은 이진트리를 사용하고 있기 때문에 한 폴더에 두 개보다 많은 하위 폴더가 존재하면 안 된다. 서브 디렉터리의 용량을 계산한 후 루트 디렉터리의 용량을 계산해야 하므로 마찬가지로 후위 순회를 사용한다.</p><p><br /></p><p><h2>스레드 이진트리</h2><strong>목적</strong> : 재귀 호출이나 다른 자료구조의 혼용 없이 순회를 구현하고 싶다.<br /> <strong>실현 방안</strong> : 트리에 존재하는 null 링크들(주로 단말 노드에 많음)을 원래 순회 과정에서 다음에 방문해야 할 노드(후속자)에 연결해놓기. 예를 들어 중위 순회이고 B - A - C 순서로 방문해야 한다면 실제 트리 구조상 연결 관계는 B ← A → C인데, 순회 순서에 맞게 B → A 링크를 만들어 둔다는 것. 이때 각 노드에 연결된 링크가 트리의 간선인지 순회를 위한 링크인지 구분하기 위한 필드 변수(bool)가 추가로 필요하다. 순회를 위해 연결하는 링크는 오른쪽 간선을 이용한다. 자세한 코드는 생략한다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/satinbower/categories/it/'>IT</a>, <a href='/satinbower/categories/data-structure/'>Data Structure</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/satinbower/tags/%EC%A7%80%EC%8B%9D/" class="post-tag no-text-decoration" >지식</a> <a href="/satinbower/tags/it/" class="post-tag no-text-decoration" >IT</a> <a href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/" class="post-tag no-text-decoration" >자료구조</a> <a href="/satinbower/tags/%ED%8A%B8%EB%A6%AC/" class="post-tag no-text-decoration" >트리</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko"> CC BY-NC-ND 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%5D+%ED%8A%B8%EB%A6%AC+-+%EC%83%88%ED%8B%B4%EB%B0%94%EC%9A%B0%EC%96%B4&url=https%3A%2F%2Fdapin1490.github.io%2Fsatinbower%2Fposts%2Fit-data-structure-tree%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/satinbower/posts/it-leetcode-230103/">[LeetCode][cpp, py] 944. Delete Columns to Make Sorted</a><li><a href="/satinbower/posts/chatgpt-230103/">Unity vs Unreal Engine</a><li><a href="/satinbower/posts/it-leetcode-221228/">[LeetCode][cpp] 1962. Remove Stones to Minimize the Total</a><li><a href="/satinbower/posts/it-leetcode-221230/">[LeetCode][cpp] 1. Two Sum</a><li><a href="/satinbower/posts/it-leetcode-230101/">[LeetCode][py] 290. Word Pattern</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower/tags/it/">IT</a> <a class="post-tag" href="/satinbower/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a> <a class="post-tag" href="/satinbower/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower/tags/leetcode/">LeetCode</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/satinbower/posts/it-data-structure-binary-search-tree/"><div class="card-body"> <em class="small" data-ts="1662457260" data-df="YYYY-MM-DD" > 2022-09-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 이진 탐색 트리</h3><div class="text-muted small"><p> 참고자료 &amp;lt;C++로 쉽게 풀어쓴 자료구조&amp;gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 9 이진 탐색 트리 이진 탐색 트리 탐색이란? 탐색 : 레코드(record)의 집합에서 특정한 레코드를 찾아내는 작업 레코드(record) : 하나 이상의 필드(field)로 구성된다 테이블(tab...</p></div></div></a></div><div class="card"> <a href="/satinbower/posts/it-priority-queue-heap/"><div class="card-body"> <em class="small" data-ts="1663157580" data-df="YYYY-MM-DD" > 2022-09-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 우선순위 큐와 힙</h3><div class="text-muted small"><p> 과제 우선순위 큐와 힙 내용 정리, C++를 이용한 우선순위큐 프로그래밍 방법 정리 백준 1966번 프린터 큐 풀이(필수) 백준 1655번 가운데를 말해요 풀이(선택) 우선순위 큐와 힙 내용 정리 힙도 자료구조다 힙 heap : 트리의 형태로 표현됨. 트리 : 사이클이 없는 그래프. 참고 : [자료구조] 트리, 참고 : [...</p></div></div></a></div><div class="card"> <a href="/satinbower/posts/it-bin-search-tree/"><div class="card-body"> <em class="small" data-ts="1663940100" data-df="YYYY-MM-DD" > 2022-09-23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] Big-O와 이진 탐색 트리</h3><div class="text-muted small"><p> 과제 아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다. 1. 스케줄링 문제에 접근하는 이진 탐색 트리 소개(필수) (-&amp;gt; 응답시간 대기시간 등등 말하는 것 같음. &quot;좋은 스케줄링은 프로세서의 효율성을 높이고, 프로세스의 응답시간을 최소화하여 시스템의 작업 처리 능력을 향상시킨다.&quot;) 2. Big-O 소개(선택) 3. 문...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/satinbower/posts/daily-220904/" class="btn btn-outline-primary" prompt="이전 글"><p>22.09.04 today I did</p></a> <a href="/satinbower/posts/daily-220905/" class="btn btn-outline-primary" prompt="다음 글"><p>22.09.05 localized heavy rain</p></a></div><script src="https://utteranc.es/client.js" repo="dapin1490/satinbower" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dapin1490">dapin1490</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY-NC-ND 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower/tags/it/">IT</a> <a class="post-tag" href="/satinbower/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a> <a class="post-tag" href="/satinbower/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower/tags/leetcode/">LeetCode</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/satinbower/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/satinbower/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/satinbower/app.js"></script>
