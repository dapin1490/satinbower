<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="퀵 정렬" /><meta name="author" content="dapin1490" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="올림피우스는 결승점의 절반을 가고, 그 나머지 절반의 절반을 가고, 또 그 절반을 가고… 더보기 데이터를 빠르게 반으로 갈라버리는 퀵 정렬을 배워보자. 부제목에 쓰인 이야기는 제논의 역설 중 하나이다. ‘아킬레우스와 거북이의 경주’도 있는데 재밌으니 한번 찾아보자. - 알아야 할 것 0. 재귀 → 백트래킹 1. 분할 정복 2. 퀵 정렬 1. 분할 정복 요약 : 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘이다. (출처 위키백과) 어려운 문제를 풀어야 할 때, 그 문제와 같은 형식으로 아주 쉬운 문제를 만들어 먼저 해결 방법을 익히고 어려운 문제를 풀어본 적이 있는가? 내가 어릴 때 읽었던 수학 소설책에서 나왔던 방법이다. 제목이 &lt;피타고라스 구출작전&gt;이었나? 같은 시리즈의 책도 한 권 더 있었는데 정확히 어느 쪽에서 나온 얘기인지는 기억나지 않는다. 그래도 어릴 때부터 지금까지 내가 잊지 않고 문제가 막히면 한번씩은 생각해보는 좋은 방법이다. 분할 정복은 이 방법과 비슷하다. 큰 문제 하나를 작은 문제 여러 개로 만들어 각각 해결한 다음 하나의 큰 답으로 만들어낸다. 2. 퀵 정렬 제논의 역설에서 올림피우스는 결승점에 도달하지 못했을지도 모르지만 퀵 정렬은 결승점에 도달할 수 있는 알고리즘이다. 그 과정을 설명하자면 다음과 같다. 여기 크기가 아주 크고 다양한 값이 뒤섞인 배열이 있다. 이 배열을 빠르게 정리하고 싶다. 우선 배열 내에서 기준이 될 값(pivot 피벗이라고 한다)을 하나 정한다. 배열의 처음과 끝에서부터 하나씩 좁혀오며 기준 값과 크기를 비교한다. 처음에서부터 오는 값을 i, 끝에서부터 오는 값을 j라고 하자. i가 기준 값보다 크고, j가 기준 값보다 작을 때 두 값을 뒤바꾼다. 이 과정을 i가 j보다 뒤에 있게 될 때까지 계속한다. i와 j는 대칭되게 이동하지 않을 수 있다. i가 j보다 뒤로 갔다면 전체 배열을 반으로 나눈다. 반으로 나눈 두 배열을 arr1, arr2라고 하자. arr1과 arr2에서 각각 기준 값을 정하고 2번의 과정을 반복한다. 끝나면 두 배열을 다시 각각 반으로 나눈다. 반으로 나누어진 배열의 크기가 1이 될 때까지 2번과 3번을 반복한다. 크기가 1인 배열은 항상 정렬되어 있는 것과 같으므로 그 때 정렬이 끝난다. 글만 보면 아쉽기도 하고, 위키백과에 좋은 이미지가 있어서 가져왔다. 다만 기준 값을 고르는 위치가 내가 뒤에 설명할 예시 코드와는 다르다는 점은 알아둬야 한다. 내 코드는 배열의 중간에 있는 값을 피벗으로 정한다. 이미지는 이해를 돕는 참고용으로만 보자! [이미지 1] 퀵 정렬 애니메이션, 출처 위키백과 3. 그래서 이걸 코드로 어떻게 쓰는데요 이번에도 직접 코드를 써볼 수 있을까 해서 해봤는데 영 신통치 않았다.. 그래서 다른 예시 참고해서 고쳐왔다. 참고한 블로그는 이쪽 : https://dpdpwl.tistory.com/46 깃허브 : [C++/퀵 정렬 예시 코드.cpp], [파이썬/퀵 정렬 예시 코드.py] [C++ 예시 코드] 부연설명 : swap 함수를 사용하지 않을 생각이라면 &lt;algorithm&gt; 클래스는 가져오지 않고, swap 없이 임시 변수를 하나 더 두어 서로 자리를 바꾸어도 된다. 프로그래머 두 명이 자리를 바꾸려면 의자 세 개가 필요하다는 말 처럼. ```cpp #include #include // swap 함수를 사용하기 위함 using namespace std;" /><meta property="og:description" content="올림피우스는 결승점의 절반을 가고, 그 나머지 절반의 절반을 가고, 또 그 절반을 가고… 더보기 데이터를 빠르게 반으로 갈라버리는 퀵 정렬을 배워보자. 부제목에 쓰인 이야기는 제논의 역설 중 하나이다. ‘아킬레우스와 거북이의 경주’도 있는데 재밌으니 한번 찾아보자. - 알아야 할 것 0. 재귀 → 백트래킹 1. 분할 정복 2. 퀵 정렬 1. 분할 정복 요약 : 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘이다. (출처 위키백과) 어려운 문제를 풀어야 할 때, 그 문제와 같은 형식으로 아주 쉬운 문제를 만들어 먼저 해결 방법을 익히고 어려운 문제를 풀어본 적이 있는가? 내가 어릴 때 읽었던 수학 소설책에서 나왔던 방법이다. 제목이 &lt;피타고라스 구출작전&gt;이었나? 같은 시리즈의 책도 한 권 더 있었는데 정확히 어느 쪽에서 나온 얘기인지는 기억나지 않는다. 그래도 어릴 때부터 지금까지 내가 잊지 않고 문제가 막히면 한번씩은 생각해보는 좋은 방법이다. 분할 정복은 이 방법과 비슷하다. 큰 문제 하나를 작은 문제 여러 개로 만들어 각각 해결한 다음 하나의 큰 답으로 만들어낸다. 2. 퀵 정렬 제논의 역설에서 올림피우스는 결승점에 도달하지 못했을지도 모르지만 퀵 정렬은 결승점에 도달할 수 있는 알고리즘이다. 그 과정을 설명하자면 다음과 같다. 여기 크기가 아주 크고 다양한 값이 뒤섞인 배열이 있다. 이 배열을 빠르게 정리하고 싶다. 우선 배열 내에서 기준이 될 값(pivot 피벗이라고 한다)을 하나 정한다. 배열의 처음과 끝에서부터 하나씩 좁혀오며 기준 값과 크기를 비교한다. 처음에서부터 오는 값을 i, 끝에서부터 오는 값을 j라고 하자. i가 기준 값보다 크고, j가 기준 값보다 작을 때 두 값을 뒤바꾼다. 이 과정을 i가 j보다 뒤에 있게 될 때까지 계속한다. i와 j는 대칭되게 이동하지 않을 수 있다. i가 j보다 뒤로 갔다면 전체 배열을 반으로 나눈다. 반으로 나눈 두 배열을 arr1, arr2라고 하자. arr1과 arr2에서 각각 기준 값을 정하고 2번의 과정을 반복한다. 끝나면 두 배열을 다시 각각 반으로 나눈다. 반으로 나누어진 배열의 크기가 1이 될 때까지 2번과 3번을 반복한다. 크기가 1인 배열은 항상 정렬되어 있는 것과 같으므로 그 때 정렬이 끝난다. 글만 보면 아쉽기도 하고, 위키백과에 좋은 이미지가 있어서 가져왔다. 다만 기준 값을 고르는 위치가 내가 뒤에 설명할 예시 코드와는 다르다는 점은 알아둬야 한다. 내 코드는 배열의 중간에 있는 값을 피벗으로 정한다. 이미지는 이해를 돕는 참고용으로만 보자! [이미지 1] 퀵 정렬 애니메이션, 출처 위키백과 3. 그래서 이걸 코드로 어떻게 쓰는데요 이번에도 직접 코드를 써볼 수 있을까 해서 해봤는데 영 신통치 않았다.. 그래서 다른 예시 참고해서 고쳐왔다. 참고한 블로그는 이쪽 : https://dpdpwl.tistory.com/46 깃허브 : [C++/퀵 정렬 예시 코드.cpp], [파이썬/퀵 정렬 예시 코드.py] [C++ 예시 코드] 부연설명 : swap 함수를 사용하지 않을 생각이라면 &lt;algorithm&gt; 클래스는 가져오지 않고, swap 없이 임시 변수를 하나 더 두어 서로 자리를 바꾸어도 된다. 프로그래머 두 명이 자리를 바꾸려면 의자 세 개가 필요하다는 말 처럼. ```cpp #include #include // swap 함수를 사용하기 위함 using namespace std;" /><link rel="canonical" href="https://dapin1490.github.io/satinbower/posts/it-quick-sort/" /><meta property="og:url" content="https://dapin1490.github.io/satinbower/posts/it-quick-sort/" /><meta property="og:site_name" content="새틴바우어" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-06T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="퀵 정렬" /><meta name="twitter:site" content="@dapin1490" /><meta name="twitter:creator" content="@dapin1490" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dapin1490"},"dateModified":"2022-02-06T00:00:00+09:00","datePublished":"2022-02-06T00:00:00+09:00","description":"올림피우스는 결승점의 절반을 가고, 그 나머지 절반의 절반을 가고, 또 그 절반을 가고… 더보기 데이터를 빠르게 반으로 갈라버리는 퀵 정렬을 배워보자. 부제목에 쓰인 이야기는 제논의 역설 중 하나이다. ‘아킬레우스와 거북이의 경주’도 있는데 재밌으니 한번 찾아보자. - 알아야 할 것 0. 재귀 → 백트래킹 1. 분할 정복 2. 퀵 정렬 1. 분할 정복 요약 : 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘이다. (출처 위키백과) 어려운 문제를 풀어야 할 때, 그 문제와 같은 형식으로 아주 쉬운 문제를 만들어 먼저 해결 방법을 익히고 어려운 문제를 풀어본 적이 있는가? 내가 어릴 때 읽었던 수학 소설책에서 나왔던 방법이다. 제목이 &lt;피타고라스 구출작전&gt;이었나? 같은 시리즈의 책도 한 권 더 있었는데 정확히 어느 쪽에서 나온 얘기인지는 기억나지 않는다. 그래도 어릴 때부터 지금까지 내가 잊지 않고 문제가 막히면 한번씩은 생각해보는 좋은 방법이다. 분할 정복은 이 방법과 비슷하다. 큰 문제 하나를 작은 문제 여러 개로 만들어 각각 해결한 다음 하나의 큰 답으로 만들어낸다. 2. 퀵 정렬 제논의 역설에서 올림피우스는 결승점에 도달하지 못했을지도 모르지만 퀵 정렬은 결승점에 도달할 수 있는 알고리즘이다. 그 과정을 설명하자면 다음과 같다. 여기 크기가 아주 크고 다양한 값이 뒤섞인 배열이 있다. 이 배열을 빠르게 정리하고 싶다. 우선 배열 내에서 기준이 될 값(pivot 피벗이라고 한다)을 하나 정한다. 배열의 처음과 끝에서부터 하나씩 좁혀오며 기준 값과 크기를 비교한다. 처음에서부터 오는 값을 i, 끝에서부터 오는 값을 j라고 하자. i가 기준 값보다 크고, j가 기준 값보다 작을 때 두 값을 뒤바꾼다. 이 과정을 i가 j보다 뒤에 있게 될 때까지 계속한다. i와 j는 대칭되게 이동하지 않을 수 있다. i가 j보다 뒤로 갔다면 전체 배열을 반으로 나눈다. 반으로 나눈 두 배열을 arr1, arr2라고 하자. arr1과 arr2에서 각각 기준 값을 정하고 2번의 과정을 반복한다. 끝나면 두 배열을 다시 각각 반으로 나눈다. 반으로 나누어진 배열의 크기가 1이 될 때까지 2번과 3번을 반복한다. 크기가 1인 배열은 항상 정렬되어 있는 것과 같으므로 그 때 정렬이 끝난다. 글만 보면 아쉽기도 하고, 위키백과에 좋은 이미지가 있어서 가져왔다. 다만 기준 값을 고르는 위치가 내가 뒤에 설명할 예시 코드와는 다르다는 점은 알아둬야 한다. 내 코드는 배열의 중간에 있는 값을 피벗으로 정한다. 이미지는 이해를 돕는 참고용으로만 보자! [이미지 1] 퀵 정렬 애니메이션, 출처 위키백과 3. 그래서 이걸 코드로 어떻게 쓰는데요 이번에도 직접 코드를 써볼 수 있을까 해서 해봤는데 영 신통치 않았다.. 그래서 다른 예시 참고해서 고쳐왔다. 참고한 블로그는 이쪽 : https://dpdpwl.tistory.com/46 깃허브 : [C++/퀵 정렬 예시 코드.cpp], [파이썬/퀵 정렬 예시 코드.py] [C++ 예시 코드] 부연설명 : swap 함수를 사용하지 않을 생각이라면 &lt;algorithm&gt; 클래스는 가져오지 않고, swap 없이 임시 변수를 하나 더 두어 서로 자리를 바꾸어도 된다. 프로그래머 두 명이 자리를 바꾸려면 의자 세 개가 필요하다는 말 처럼. ```cpp #include #include // swap 함수를 사용하기 위함 using namespace std;","headline":"퀵 정렬","mainEntityOfPage":{"@type":"WebPage","@id":"https://dapin1490.github.io/satinbower/posts/it-quick-sort/"},"url":"https://dapin1490.github.io/satinbower/posts/it-quick-sort/"}</script><title>퀵 정렬 | 새틴바우어</title><link rel="apple-touch-icon" sizes="180x180" href="/satinbower/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/satinbower/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/satinbower/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/satinbower/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/satinbower/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="새틴바우어"><meta name="application-name" content="새틴바우어"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/satinbower/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/satinbower/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/satinbower/" class="mx-auto"> <img src="/satinbower/assets/img/profile_image.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/satinbower/">새틴바우어</a></div><div class="site-subtitle font-italic">dapin1490's hand-made study blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/satinbower/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/satinbower/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/satinbower/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/satinbower/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/satinbower/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dapin1490" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dapin1490" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dapin1490','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/satinbower/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/satinbower/"> 홈 </a> </span> <span>퀵 정렬</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>퀵 정렬</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1644073200" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-02-06 </em> </span><div class="d-flex justify-content-between"> <span> By <em> dapin1490 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1916 단어"> <em>10 분</em>읽는 시간</span></div></div></div><div class="post-content"><h3 id="올림피우스는-결승점의-절반을-가고-그-나머지-절반의-절반을-가고-또-그-절반을-가고-더보기"><span class="mr-2">올림피우스는 결승점의 절반을 가고, 그 나머지 절반의 절반을 가고, 또 그 절반을 가고… 더보기</span><a href="#올림피우스는-결승점의-절반을-가고-그-나머지-절반의-절반을-가고-또-그-절반을-가고-더보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p><br /></p><p>데이터를 빠르게 반으로 갈라버리는 퀵 정렬을 배워보자. 부제목에 쓰인 이야기는 제논의 역설 중 하나이다. ‘아킬레우스와 거북이의 경주’도 있는데 재밌으니 한번 찾아보자.</p><p><br /><br /></p><h3 id="--알아야-할-것"><span class="mr-2">- 알아야 할 것</span><a href="#--알아야-할-것" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>0. 재귀 → <a href="https://dapin1490.github.io/satinbower/posts/it-backtracking/" target="_blank" title="새 탭에서 보기">백트래킹</a><br /> 1. 분할 정복<br /> 2. 퀵 정렬</p><p><br /><br /></p><h3 id="1-분할-정복"><span class="mr-2">1. 분할 정복</span><a href="#1-분할-정복" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>요약 : 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘이다. (출처 위키백과) <br /> 어려운 문제를 풀어야 할 때, 그 문제와 같은 형식으로 아주 쉬운 문제를 만들어 먼저 해결 방법을 익히고 어려운 문제를 풀어본 적이 있는가? 내가 어릴 때 읽었던 수학 소설책에서 나왔던 방법이다. 제목이 &lt;피타고라스 구출작전&gt;이었나? 같은 시리즈의 책도 한 권 더 있었는데 정확히 어느 쪽에서 나온 얘기인지는 기억나지 않는다. 그래도 어릴 때부터 지금까지 내가 잊지 않고 문제가 막히면 한번씩은 생각해보는 좋은 방법이다. 분할 정복은 이 방법과 비슷하다. 큰 문제 하나를 작은 문제 여러 개로 만들어 각각 해결한 다음 하나의 큰 답으로 만들어낸다.</p><p><br /><br /></p><h3 id="2-퀵-정렬"><span class="mr-2">2. 퀵 정렬</span><a href="#2-퀵-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>제논의 역설에서 올림피우스는 결승점에 도달하지 못했을지도 모르지만 퀵 정렬은 결승점에 도달할 수 있는 알고리즘이다. 그 과정을 설명하자면 다음과 같다.</p><ol><li>여기 크기가 아주 크고 다양한 값이 뒤섞인 배열이 있다. 이 배열을 빠르게 정리하고 싶다. 우선 배열 내에서 기준이 될 값(pivot 피벗이라고 한다)을 하나 정한다.<li>배열의 처음과 끝에서부터 하나씩 좁혀오며 기준 값과 크기를 비교한다. 처음에서부터 오는 값을 i, 끝에서부터 오는 값을 j라고 하자. i가 기준 값보다 크고, j가 기준 값보다 작을 때 두 값을 뒤바꾼다. 이 과정을 i가 j보다 뒤에 있게 될 때까지 계속한다. i와 j는 대칭되게 이동하지 않을 수 있다.<li>i가 j보다 뒤로 갔다면 전체 배열을 반으로 나눈다. 반으로 나눈 두 배열을 arr1, arr2라고 하자. arr1과 arr2에서 각각 기준 값을 정하고 2번의 과정을 반복한다. 끝나면 두 배열을 다시 각각 반으로 나눈다.<li>반으로 나누어진 배열의 크기가 1이 될 때까지 2번과 3번을 반복한다. 크기가 1인 배열은 항상 정렬되어 있는 것과 같으므로 그 때 정렬이 끝난다.</ol><p>글만 보면 아쉽기도 하고, 위키백과에 좋은 이미지가 있어서 가져왔다. 다만 기준 값을 고르는 위치가 내가 뒤에 설명할 예시 코드와는 다르다는 점은 알아둬야 한다. 내 코드는 배열의 중간에 있는 값을 피벗으로 정한다. 이미지는 이해를 돕는 참고용으로만 보자!</p><figure style="text-align:center"> <img data-src="/satinbower/assets/img/category-it/220206-1-quick-sort.gif" data-proofer-ignore><figcaption>[이미지 1] 퀵 정렬 애니메이션, 출처 위키백과</figcaption></figure><p><br /><br /></p><h3 id="3-그래서-이걸-코드로-어떻게-쓰는데요"><span class="mr-2">3. 그래서 이걸 코드로 어떻게 쓰는데요</span><a href="#3-그래서-이걸-코드로-어떻게-쓰는데요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이번에도 직접 코드를 써볼 수 있을까 해서 해봤는데 영 신통치 않았다.. 그래서 다른 예시 참고해서 고쳐왔다. 참고한 블로그는 이쪽 : <a href="https://dpdpwl.tistory.com/46">https://dpdpwl.tistory.com/46</a></p><p><a href="https://github.com/dapin1490/study-note">깃허브</a> : [<a href="https://github.com/dapin1490/study-note/blob/main/cpp/%ED%80%B5%20%EC%A0%95%EB%A0%AC%20%EC%98%88%EC%8B%9C.cpp">C++/퀵 정렬 예시 코드.cpp</a>], [<a href="https://github.com/dapin1490/study-note/blob/main/%ED%8C%8C%EC%9D%B4%EC%8D%AC/%ED%80%B5%20%EC%A0%95%EB%A0%AC%20%EC%98%88%EC%8B%9C.py">파이썬/퀵 정렬 예시 코드.py</a>]</p><p>[C++ 예시 코드]</p><p>부연설명 : swap 함수를 사용하지 않을 생각이라면 &lt;algorithm&gt; 클래스는 가져오지 않고, swap 없이 임시 변수를 하나 더 두어 서로 자리를 바꾸어도 된다. 프로그래머 두 명이 자리를 바꾸려면 의자 세 개가 필요하다는 말 처럼.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="c1"> // swap 함수를 사용하기 위함</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// 퀵 정렬 함수</span>
<span class="kt">void</span> <span class="nf">qsort</span><span class="p">(</span><span class="kt">int</span> <span class="n">list</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// 배열 크기</span>
    <span class="kt">int</span> <span class="n">ar</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span> <span class="p">};</span> <span class="c1">// 정렬할 배열</span>
    
    <span class="n">qsort</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 정렬 함수 호출</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 정렬한 배열 출력</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 퀵 정렬 함수</span>
<span class="kt">void</span> <span class="n">qsort</span><span class="p">(</span><span class="kt">int</span> <span class="n">list</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="c1">// 배열은 기본적으로 참조 전달이기 때문에 &amp;를 붙이면 안 된다</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 기준 값 피벗</span>
    <span class="kt">int</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 다음 호출에 쓸 i</span>
    <span class="kt">int</span> <span class="n">nj</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// 다음 호출에 쓸 j</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">)</span> <span class="c1">// 배열 크기가 1이라면 정렬 끝, 리턴</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// i와 j가 만나면 중단</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">list</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="c1">// i 쪽에서 기준 값보다 큰 값 찾기</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">list</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="c1">// j 쪽에서 기준 값보다 작은 값 찾기</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// i가 왼쪽에 있고 j가 오른쪽에 있을 때에만 실행, 겹쳐도 된다.</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span> <span class="c1">// i와 j 자리에 있는 두 요소를 서로 바꿈</span>
            <span class="c1">// 사용한 i와 j를 바꿔주지 않으면 무한루프가 생김</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 나누어진 배열 양쪽에 대한 재귀 호출</span>
    <span class="n">qsort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="n">qsort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nj</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>[파이썬 소스 코드]</p><p>참고 : 파이썬은 프로그래머 두 명이 의자 두 개만으로도 자리를 바꿀 수 있는 언어이기 때문에 굳이 swap 함수 같은 것이 필요하지 않다.</p><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1"># 퀵 정렬 함수
</span><span class="k">def</span> <span class="nf">qsort</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># 기준 값 피벗
</span>    <span class="n">next_i</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># 다음 호출에 쓸 i
</span>    <span class="n">next_j</span> <span class="o">=</span> <span class="n">j</span>  <span class="c1"># 다음 호출에 쓸 j
</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># 배열 크기가 1이라면 정렬 끝, 리턴
</span>        <span class="k">return</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># i와 j가 만나면 중단
</span>        <span class="k">while</span> <span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lis</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>  <span class="c1"># i 쪽에서 기준 값보다 큰 값 찾기
</span>            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">lis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lis</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>  <span class="c1"># j 쪽에서 기준 값보다 작은 값 찾기
</span>            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># i가 왼쪽에 있고 j가 오른쪽에 있을 때에만 실행, 겹쳐도 된다.
</span>            <span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lis</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># i와 j 자리에 있는 두 요소를 서로 바꿈
</span>            <span class="c1"># 사용한 i와 j를 바꿔주지 않으면 무한루프가 생김
</span>            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># 나누어진 배열 양쪽에 대한 재귀 호출
</span>    <span class="n">qsort</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">next_i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="n">qsort</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">next_j</span><span class="p">)</span>


<span class="n">ar</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>  <span class="c1"># 정렬할 배열
</span><span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>  <span class="c1"># 배열 크기
</span>
<span class="n">qsort</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 정렬 함수 호출
</span>
<span class="k">print</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>  <span class="c1"># 정렬한 배열 출력
</span></pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/satinbower/categories/it/'>IT</a>, <a href='/satinbower/categories/algorithm/'>Algorithm</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/satinbower/tags/%EC%A7%80%EC%8B%9D/" class="post-tag no-text-decoration" >지식</a> <a href="/satinbower/tags/it/" class="post-tag no-text-decoration" >IT</a> <a href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" class="post-tag no-text-decoration" >알고리즘</a> <a href="/satinbower/tags/%ED%80%B5%EC%A0%95%EB%A0%AC/" class="post-tag no-text-decoration" >퀵정렬</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko"> CC BY-NC-ND 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%ED%80%B5+%EC%A0%95%EB%A0%AC+-+%EC%83%88%ED%8B%B4%EB%B0%94%EC%9A%B0%EC%96%B4&url=https%3A%2F%2Fdapin1490.github.io%2Fsatinbower%2Fposts%2Fit-quick-sort%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/satinbower/posts/it-leetcode-230103/">[LeetCode][cpp, py] 944. Delete Columns to Make Sorted</a><li><a href="/satinbower/posts/chatgpt-230103/">Unity vs Unreal Engine</a><li><a href="/satinbower/posts/it-leetcode-221228/">[LeetCode][cpp] 1962. Remove Stones to Minimize the Total</a><li><a href="/satinbower/posts/it-leetcode-221230/">[LeetCode][cpp] 1. Two Sum</a><li><a href="/satinbower/posts/it-leetcode-230101/">[LeetCode][py] 290. Word Pattern</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower/tags/it/">IT</a> <a class="post-tag" href="/satinbower/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a> <a class="post-tag" href="/satinbower/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower/tags/leetcode/">LeetCode</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/satinbower/posts/it-backtracking/"><div class="card-body"> <em class="small" data-ts="1643382000" data-df="YYYY-MM-DD" > 2022-01-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>백트래킹</h3><div class="text-muted small"><p> 2580 스도쿠 미해결로 인해 풀이 대신 공부함 문제 참고(출처 : 백준) 15649 N과 M (1), 15650 N과 M (2), 15651 N과 M (3), 15652 N과 M (4) 9663 N-Queen, 2580 스도쿠 목차 - 재귀와 호출 스택 - 깊이 우선 탐색 - 백트래킹 재귀와 호출 스택 가볍게 “재귀”의 정의...</p></div></div></a></div><div class="card"> <a href="/satinbower/posts/it-counting-sort/"><div class="card-body"> <em class="small" data-ts="1643382000" data-df="YYYY-MM-DD" > 2022-01-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>카운팅 정렬(+ 선택 정렬)</h3><div class="text-muted small"><p> 이 수는 몇 개 있으니까 여기 놓고 저 수는 몇 개 있으니까 저기 놓고… 더보기 많고 많은 정렬 알고리즘 중 정렬할 수의 범위가 한정적일 때 쓸 수 있는 카운팅 정렬을 공부해 보자. 선택 정렬은 덤이다. 1. 정렬 알고리즘 위키백과에 따르면 ‘원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘’이라고 한다. 선택 정렬...</p></div></div></a></div><div class="card"> <a href="/satinbower/posts/it-kadane-algorithm/"><div class="card-body"> <em class="small" data-ts="1652799600" data-df="YYYY-MM-DD" > 2022-05-18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>카데인 알고리즘</h3><div class="text-muted small"><p> 뭐 별 게 다 있어.. 프로그래머란 대체 자 생각을 해보자. 어떤 배열에서 연속한 원소로 이루어진 부분 배열의 합의 최댓값을 찾고 싶다. 그런데 시간이 별로 없다. 이럴 때 쓰는 게 카데인 알고리즘이다. 이중 반복문으로 답을 찾는 브루트포스는 시간복잡도가 O(n²)이지만 이 알고리즘은 O(n)이다. 목차 1. 동적 계획법 2. 카데인 알...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/satinbower/posts/it-counting-sort/" class="btn btn-outline-primary" prompt="이전 글"><p>카운팅 정렬(+ 선택 정렬)</p></a> <a href="/satinbower/posts/it-deeplearning-data-1/" class="btn btn-outline-primary" prompt="다음 글"><p>딥러닝 모델에게 데이터 떠먹이는 방법 (1)</p></a></div><script src="https://utteranc.es/client.js" repo="dapin1490/satinbower" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dapin1490">dapin1490</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY-NC-ND 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower/tags/it/">IT</a> <a class="post-tag" href="/satinbower/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a> <a class="post-tag" href="/satinbower/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower/tags/leetcode/">LeetCode</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/satinbower/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/satinbower/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/satinbower/app.js"></script>
