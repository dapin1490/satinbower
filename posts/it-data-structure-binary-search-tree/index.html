<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="[자료구조] 이진 탐색 트리" /><meta name="author" content="dapin1490" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="참고자료 &lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 9 이진 탐색 트리 이진 탐색 트리 탐색이란? 탐색 : 레코드(record)의 집합에서 특정한 레코드를 찾아내는 작업 레코드(record) : 하나 이상의 필드(field)로 구성된다 테이블(table) : 레코드의 집합 키(key) : 레코드를 식별할 수 있게 하는 필드 주요키(primary key) : 서로 중복되지 않는 고유한 값을 갖는 키 이진 탐색 트리란? 이진트리 기반, 효율적인 탐색을 위한 자료구조. 다음 조건을 만족해야 한다. 이 정의에 따라 이진 탐색 트리는 어느 정도 정렬된 상태를 유지하게 된다. 모든 노드는 유일한 키를 갖는다. 왼쪽 서브트리의 키들은 루트의 키보다 작다. 오른쪽 서브트리의 키들은 루트의 키보다 크다. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다. 이진 탐색 트리의 추상 자료형 이진 탐색 트리의 특성을 항상 만족하도록 하면서 삽입, 삭제, 탐색을 할 수 있어야 한다. 자세한 추상 자료형은 책으로 보자. 이진트리의 기본적인 모든 연산 또한 사용 가능하다. 이진 탐색 트리의 기본 틀 설계 이 책에서는 앞 챕터에서 만든 이진트리 클래스를 상속하고 삽입, 삭제, 탐색 함수를 추가했다. 이진 탐색 트리의 연산 탐색 연산 비교한 값이 루트보다 작으면 왼쪽으로, 크면 오른쪽으로, 같으면 탐색이 끝난다. 재귀를 기반으로 하나 반복으로 구현할 수 있다고 한다. 반복으로 구현한 함수에서는 while을 사용했다. 함수는 이진 탐색 트리에서 구현하는 방법도 있고, 노드 클래스에서 구현하는 방법도 있다. 자세한 코드는 생략한다. 삽입 연산 삽입하기에 앞서 적절한 자리를 찾기 위해 탐색을 해야 한다. 탐색해서 같은 값을 찾으면 키가 중복되므로 삽입할 수 없고, 탐색에 실패하면 같은 키가 없는 것이므로 실패한 자리에 삽입하면 된다. 마찬가지로 재귀와 반복 모두 구현 가능하다. 삭제 연산 삭제할 노드를 찾기 위해 탐색을 먼저 해야 하며, 세 가지 상황으로 나뉜다. 삭제하려는 노드가 단말 노드일 때 : 그냥 지우면 된다. 삭제하려는 노드가 양쪽 서브트리 중 하나만 가질 때 : 노드를 삭제한 후 서브트리를 이어붙이면 된다. 삭제하려는 노드가 양쪽 서브트리를 모두 가질 때 : 두 서브트리 중 하나를 루트로 만들어 이어붙여야 한다. 삭제하려는 노드가 단말 노드일 때 해당 노드의 부모 노드를 찾아서 링크를 null로 만들고 해당 노드는 메모리를 동적으로 해제하면 된다. 이때 삭제할 노드와 부모 노드를 함께 알아야만 삭제가 가능하다. 삭제하려는 노드가 서브트리를 하나 가질 때 해당 노드를 삭제한 후 자식으로 있던 서브트리를 붙이면 된다. 부모 노드와 자식 노드를 알아야 한다. 삭제하려는 노드가 서브트리를 두 개 가질 때 해당 노드를 삭제한 후 왼쪽이나 오른쪽 서브트리를 이어 붙이면 되는데, 붙이고 나서도 이진 탐색 트리의 조건을 만족해야 한다. 고로 삭제되는 노드와 가장 값이 비슷한 노드를 붙여야 한다. 삭제되는 노드와 가장 비슷한 노드는 왼쪽 서브트리의 가장 오른쪽 값과 오른쪽 서브트리의 가장 왼쪽 값이다. 책의 설명에 의하면 둘 중 어떤 것을 선택해도 상관 없으며 여기서는 오른쪽 서브트리의 값을 선택한다고 한다. 이어 붙일 노드를 정했다면 원래 있던 노드를 삭제한 자리로 옮기면 된다. 서브트리를 모두 옮기는 것이 아니고 단말 노드 하나만을 옮긴다. 이 과정을 수행하기 위해 삭제할 노드, 삭제 노드의 부모 노드, 후계자 노드, 후계자 노드의 부모 노드를 알아야 한다. 이중 후계 노드와 후계 노드의 부모 노드는 함수 내에서 탐색을 통해 찾을 수 있으므로 함수에는 삭제 노드와 삭제 노드의 부모 노드만 전달하면 된다. 세 가지 경우 모두 삭제 노드와 삭제 노드의 부모 노드만 알면 수행 가능하므로 하나의 함수로 구현하고 선택문을 두어 세 가지 경우를 구분하여 처리한다. 복수의 노드 정보를 필요로 하므로 노드 클래스에서 구현할 수는 없다. 이진 탐색 프로그램 위에서 설계한 이진 트리 클래스를 종합하고 인스턴스를 생성하여 테스트해본다. 이진 탐색 트리의 성능 분석 이진 탐색 트리의 시간 복잡도에 대해 설명하고 있다. 균형 트리에 대해 언급하였다. 이진 탐색 트리의 응용: 영어 사전 꼭 영어 사전일 필요는 없다. 트리에 저장되는 레코드는 단어와 의미를 갖고, 단어는 공백이 없는 하나의 문자열, 의미는 여러 개의 단어로 이루어진 문자열이다. 사전의 기능은 입력, 삭제, 단어 탐색, 의미 탐색, 사전 출력, 종료로 구성된다." /><meta property="og:description" content="참고자료 &lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 9 이진 탐색 트리 이진 탐색 트리 탐색이란? 탐색 : 레코드(record)의 집합에서 특정한 레코드를 찾아내는 작업 레코드(record) : 하나 이상의 필드(field)로 구성된다 테이블(table) : 레코드의 집합 키(key) : 레코드를 식별할 수 있게 하는 필드 주요키(primary key) : 서로 중복되지 않는 고유한 값을 갖는 키 이진 탐색 트리란? 이진트리 기반, 효율적인 탐색을 위한 자료구조. 다음 조건을 만족해야 한다. 이 정의에 따라 이진 탐색 트리는 어느 정도 정렬된 상태를 유지하게 된다. 모든 노드는 유일한 키를 갖는다. 왼쪽 서브트리의 키들은 루트의 키보다 작다. 오른쪽 서브트리의 키들은 루트의 키보다 크다. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다. 이진 탐색 트리의 추상 자료형 이진 탐색 트리의 특성을 항상 만족하도록 하면서 삽입, 삭제, 탐색을 할 수 있어야 한다. 자세한 추상 자료형은 책으로 보자. 이진트리의 기본적인 모든 연산 또한 사용 가능하다. 이진 탐색 트리의 기본 틀 설계 이 책에서는 앞 챕터에서 만든 이진트리 클래스를 상속하고 삽입, 삭제, 탐색 함수를 추가했다. 이진 탐색 트리의 연산 탐색 연산 비교한 값이 루트보다 작으면 왼쪽으로, 크면 오른쪽으로, 같으면 탐색이 끝난다. 재귀를 기반으로 하나 반복으로 구현할 수 있다고 한다. 반복으로 구현한 함수에서는 while을 사용했다. 함수는 이진 탐색 트리에서 구현하는 방법도 있고, 노드 클래스에서 구현하는 방법도 있다. 자세한 코드는 생략한다. 삽입 연산 삽입하기에 앞서 적절한 자리를 찾기 위해 탐색을 해야 한다. 탐색해서 같은 값을 찾으면 키가 중복되므로 삽입할 수 없고, 탐색에 실패하면 같은 키가 없는 것이므로 실패한 자리에 삽입하면 된다. 마찬가지로 재귀와 반복 모두 구현 가능하다. 삭제 연산 삭제할 노드를 찾기 위해 탐색을 먼저 해야 하며, 세 가지 상황으로 나뉜다. 삭제하려는 노드가 단말 노드일 때 : 그냥 지우면 된다. 삭제하려는 노드가 양쪽 서브트리 중 하나만 가질 때 : 노드를 삭제한 후 서브트리를 이어붙이면 된다. 삭제하려는 노드가 양쪽 서브트리를 모두 가질 때 : 두 서브트리 중 하나를 루트로 만들어 이어붙여야 한다. 삭제하려는 노드가 단말 노드일 때 해당 노드의 부모 노드를 찾아서 링크를 null로 만들고 해당 노드는 메모리를 동적으로 해제하면 된다. 이때 삭제할 노드와 부모 노드를 함께 알아야만 삭제가 가능하다. 삭제하려는 노드가 서브트리를 하나 가질 때 해당 노드를 삭제한 후 자식으로 있던 서브트리를 붙이면 된다. 부모 노드와 자식 노드를 알아야 한다. 삭제하려는 노드가 서브트리를 두 개 가질 때 해당 노드를 삭제한 후 왼쪽이나 오른쪽 서브트리를 이어 붙이면 되는데, 붙이고 나서도 이진 탐색 트리의 조건을 만족해야 한다. 고로 삭제되는 노드와 가장 값이 비슷한 노드를 붙여야 한다. 삭제되는 노드와 가장 비슷한 노드는 왼쪽 서브트리의 가장 오른쪽 값과 오른쪽 서브트리의 가장 왼쪽 값이다. 책의 설명에 의하면 둘 중 어떤 것을 선택해도 상관 없으며 여기서는 오른쪽 서브트리의 값을 선택한다고 한다. 이어 붙일 노드를 정했다면 원래 있던 노드를 삭제한 자리로 옮기면 된다. 서브트리를 모두 옮기는 것이 아니고 단말 노드 하나만을 옮긴다. 이 과정을 수행하기 위해 삭제할 노드, 삭제 노드의 부모 노드, 후계자 노드, 후계자 노드의 부모 노드를 알아야 한다. 이중 후계 노드와 후계 노드의 부모 노드는 함수 내에서 탐색을 통해 찾을 수 있으므로 함수에는 삭제 노드와 삭제 노드의 부모 노드만 전달하면 된다. 세 가지 경우 모두 삭제 노드와 삭제 노드의 부모 노드만 알면 수행 가능하므로 하나의 함수로 구현하고 선택문을 두어 세 가지 경우를 구분하여 처리한다. 복수의 노드 정보를 필요로 하므로 노드 클래스에서 구현할 수는 없다. 이진 탐색 프로그램 위에서 설계한 이진 트리 클래스를 종합하고 인스턴스를 생성하여 테스트해본다. 이진 탐색 트리의 성능 분석 이진 탐색 트리의 시간 복잡도에 대해 설명하고 있다. 균형 트리에 대해 언급하였다. 이진 탐색 트리의 응용: 영어 사전 꼭 영어 사전일 필요는 없다. 트리에 저장되는 레코드는 단어와 의미를 갖고, 단어는 공백이 없는 하나의 문자열, 의미는 여러 개의 단어로 이루어진 문자열이다. 사전의 기능은 입력, 삭제, 단어 탐색, 의미 탐색, 사전 출력, 종료로 구성된다." /><link rel="canonical" href="https://dapin1490.github.io/satinbower/posts/it-data-structure-binary-search-tree/" /><meta property="og:url" content="https://dapin1490.github.io/satinbower/posts/it-data-structure-binary-search-tree/" /><meta property="og:site_name" content="새틴바우어" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-06T18:41:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[자료구조] 이진 탐색 트리" /><meta name="twitter:site" content="@dapin1490" /><meta name="twitter:creator" content="@dapin1490" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dapin1490"},"dateModified":"2022-09-06T18:41:00+09:00","datePublished":"2022-09-06T18:41:00+09:00","description":"참고자료 &lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 9 이진 탐색 트리 이진 탐색 트리 탐색이란? 탐색 : 레코드(record)의 집합에서 특정한 레코드를 찾아내는 작업 레코드(record) : 하나 이상의 필드(field)로 구성된다 테이블(table) : 레코드의 집합 키(key) : 레코드를 식별할 수 있게 하는 필드 주요키(primary key) : 서로 중복되지 않는 고유한 값을 갖는 키 이진 탐색 트리란? 이진트리 기반, 효율적인 탐색을 위한 자료구조. 다음 조건을 만족해야 한다. 이 정의에 따라 이진 탐색 트리는 어느 정도 정렬된 상태를 유지하게 된다. 모든 노드는 유일한 키를 갖는다. 왼쪽 서브트리의 키들은 루트의 키보다 작다. 오른쪽 서브트리의 키들은 루트의 키보다 크다. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다. 이진 탐색 트리의 추상 자료형 이진 탐색 트리의 특성을 항상 만족하도록 하면서 삽입, 삭제, 탐색을 할 수 있어야 한다. 자세한 추상 자료형은 책으로 보자. 이진트리의 기본적인 모든 연산 또한 사용 가능하다. 이진 탐색 트리의 기본 틀 설계 이 책에서는 앞 챕터에서 만든 이진트리 클래스를 상속하고 삽입, 삭제, 탐색 함수를 추가했다. 이진 탐색 트리의 연산 탐색 연산 비교한 값이 루트보다 작으면 왼쪽으로, 크면 오른쪽으로, 같으면 탐색이 끝난다. 재귀를 기반으로 하나 반복으로 구현할 수 있다고 한다. 반복으로 구현한 함수에서는 while을 사용했다. 함수는 이진 탐색 트리에서 구현하는 방법도 있고, 노드 클래스에서 구현하는 방법도 있다. 자세한 코드는 생략한다. 삽입 연산 삽입하기에 앞서 적절한 자리를 찾기 위해 탐색을 해야 한다. 탐색해서 같은 값을 찾으면 키가 중복되므로 삽입할 수 없고, 탐색에 실패하면 같은 키가 없는 것이므로 실패한 자리에 삽입하면 된다. 마찬가지로 재귀와 반복 모두 구현 가능하다. 삭제 연산 삭제할 노드를 찾기 위해 탐색을 먼저 해야 하며, 세 가지 상황으로 나뉜다. 삭제하려는 노드가 단말 노드일 때 : 그냥 지우면 된다. 삭제하려는 노드가 양쪽 서브트리 중 하나만 가질 때 : 노드를 삭제한 후 서브트리를 이어붙이면 된다. 삭제하려는 노드가 양쪽 서브트리를 모두 가질 때 : 두 서브트리 중 하나를 루트로 만들어 이어붙여야 한다. 삭제하려는 노드가 단말 노드일 때 해당 노드의 부모 노드를 찾아서 링크를 null로 만들고 해당 노드는 메모리를 동적으로 해제하면 된다. 이때 삭제할 노드와 부모 노드를 함께 알아야만 삭제가 가능하다. 삭제하려는 노드가 서브트리를 하나 가질 때 해당 노드를 삭제한 후 자식으로 있던 서브트리를 붙이면 된다. 부모 노드와 자식 노드를 알아야 한다. 삭제하려는 노드가 서브트리를 두 개 가질 때 해당 노드를 삭제한 후 왼쪽이나 오른쪽 서브트리를 이어 붙이면 되는데, 붙이고 나서도 이진 탐색 트리의 조건을 만족해야 한다. 고로 삭제되는 노드와 가장 값이 비슷한 노드를 붙여야 한다. 삭제되는 노드와 가장 비슷한 노드는 왼쪽 서브트리의 가장 오른쪽 값과 오른쪽 서브트리의 가장 왼쪽 값이다. 책의 설명에 의하면 둘 중 어떤 것을 선택해도 상관 없으며 여기서는 오른쪽 서브트리의 값을 선택한다고 한다. 이어 붙일 노드를 정했다면 원래 있던 노드를 삭제한 자리로 옮기면 된다. 서브트리를 모두 옮기는 것이 아니고 단말 노드 하나만을 옮긴다. 이 과정을 수행하기 위해 삭제할 노드, 삭제 노드의 부모 노드, 후계자 노드, 후계자 노드의 부모 노드를 알아야 한다. 이중 후계 노드와 후계 노드의 부모 노드는 함수 내에서 탐색을 통해 찾을 수 있으므로 함수에는 삭제 노드와 삭제 노드의 부모 노드만 전달하면 된다. 세 가지 경우 모두 삭제 노드와 삭제 노드의 부모 노드만 알면 수행 가능하므로 하나의 함수로 구현하고 선택문을 두어 세 가지 경우를 구분하여 처리한다. 복수의 노드 정보를 필요로 하므로 노드 클래스에서 구현할 수는 없다. 이진 탐색 프로그램 위에서 설계한 이진 트리 클래스를 종합하고 인스턴스를 생성하여 테스트해본다. 이진 탐색 트리의 성능 분석 이진 탐색 트리의 시간 복잡도에 대해 설명하고 있다. 균형 트리에 대해 언급하였다. 이진 탐색 트리의 응용: 영어 사전 꼭 영어 사전일 필요는 없다. 트리에 저장되는 레코드는 단어와 의미를 갖고, 단어는 공백이 없는 하나의 문자열, 의미는 여러 개의 단어로 이루어진 문자열이다. 사전의 기능은 입력, 삭제, 단어 탐색, 의미 탐색, 사전 출력, 종료로 구성된다.","headline":"[자료구조] 이진 탐색 트리","mainEntityOfPage":{"@type":"WebPage","@id":"https://dapin1490.github.io/satinbower/posts/it-data-structure-binary-search-tree/"},"url":"https://dapin1490.github.io/satinbower/posts/it-data-structure-binary-search-tree/"}</script><title>[자료구조] 이진 탐색 트리 | 새틴바우어</title><link rel="apple-touch-icon" sizes="180x180" href="/satinbower/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/satinbower/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/satinbower/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/satinbower/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/satinbower/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="새틴바우어"><meta name="application-name" content="새틴바우어"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/satinbower/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/satinbower/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/satinbower/" class="mx-auto"> <img src="/satinbower/assets/img/profile_image.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/satinbower/">새틴바우어</a></div><div class="site-subtitle font-italic">dapin1490's hand-made study blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/satinbower/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/satinbower/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/satinbower/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/satinbower/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/satinbower/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dapin1490" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dapin1490" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dapin1490','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/satinbower/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/satinbower/"> 홈 </a> </span> <span>[자료구조] 이진 탐색 트리</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[자료구조] 이진 탐색 트리</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1662457260" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-09-06 </em> </span><div class="d-flex justify-content-between"> <span> By <em> dapin1490 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1606 단어"> <em>8 분</em>읽는 시간</span></div></div></div><div class="post-content"><p><h2>참고자료</h2>&lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사<br /> 공부 범위 : 챕터 9 이진 탐색 트리</p><p><br /></p><p><h2>이진 탐색 트리</h2><h3>탐색이란?</h3><ul><li>탐색 : 레코드(record)의 집합에서 특정한 레코드를 찾아내는 작업<li>레코드(record) : 하나 이상의 필드(field)로 구성된다<li>테이블(table) : 레코드의 집합<li>키(key) : 레코드를 식별할 수 있게 하는 필드<li>주요키(primary key) : 서로 중복되지 않는 고유한 값을 갖는 키</ul><h3>이진 탐색 트리란?</h3>이진트리 기반, 효율적인 탐색을 위한 자료구조. 다음 조건을 만족해야 한다. 이 정의에 따라 이진 탐색 트리는 어느 정도 정렬된 상태를 유지하게 된다.<ul><li>모든 노드는 유일한 키를 갖는다.<li>왼쪽 서브트리의 키들은 루트의 키보다 작다.<li>오른쪽 서브트리의 키들은 루트의 키보다 크다.<li>왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.</ul><h3>이진 탐색 트리의 추상 자료형</h3>이진 탐색 트리의 특성을 항상 만족하도록 하면서 삽입, 삭제, 탐색을 할 수 있어야 한다. 자세한 추상 자료형은 책으로 보자. 이진트리의 기본적인 모든 연산 또한 사용 가능하다.<h3>이진 탐색 트리의 기본 틀 설계</h3>이 책에서는 앞 챕터에서 만든 이진트리 클래스를 상속하고 삽입, 삭제, 탐색 함수를 추가했다.</p><p><br /></p><p><h2>이진 탐색 트리의 연산</h2><h3>탐색 연산</h3>비교한 값이 루트보다 작으면 왼쪽으로, 크면 오른쪽으로, 같으면 탐색이 끝난다. 재귀를 기반으로 하나 반복으로 구현할 수 있다고 한다. 반복으로 구현한 함수에서는 while을 사용했다. 함수는 이진 탐색 트리에서 구현하는 방법도 있고, 노드 클래스에서 구현하는 방법도 있다. 자세한 코드는 생략한다.<h3>삽입 연산</h3>삽입하기에 앞서 적절한 자리를 찾기 위해 탐색을 해야 한다. 탐색해서 같은 값을 찾으면 키가 중복되므로 삽입할 수 없고, 탐색에 실패하면 같은 키가 없는 것이므로 실패한 자리에 삽입하면 된다. 마찬가지로 재귀와 반복 모두 구현 가능하다.<h3>삭제 연산</h3>삭제할 노드를 찾기 위해 탐색을 먼저 해야 하며, 세 가지 상황으로 나뉜다.<ul><li>삭제하려는 노드가 단말 노드일 때 : 그냥 지우면 된다.<li>삭제하려는 노드가 양쪽 서브트리 중 하나만 가질 때 : 노드를 삭제한 후 서브트리를 이어붙이면 된다.<li>삭제하려는 노드가 양쪽 서브트리를 모두 가질 때 : 두 서브트리 중 하나를 루트로 만들어 이어붙여야 한다.</ul><strong>삭제하려는 노드가 단말 노드일 때</strong><br /> 해당 노드의 부모 노드를 찾아서 링크를 null로 만들고 해당 노드는 메모리를 동적으로 해제하면 된다. 이때 삭제할 노드와 부모 노드를 함께 알아야만 삭제가 가능하다.<br /> <br /> <strong>삭제하려는 노드가 서브트리를 하나 가질 때</strong><br /> 해당 노드를 삭제한 후 자식으로 있던 서브트리를 붙이면 된다. 부모 노드와 자식 노드를 알아야 한다.<br /> <br /> <strong>삭제하려는 노드가 서브트리를 두 개 가질 때</strong><br /> 해당 노드를 삭제한 후 왼쪽이나 오른쪽 서브트리를 이어 붙이면 되는데, 붙이고 나서도 이진 탐색 트리의 조건을 만족해야 한다. 고로 삭제되는 노드와 가장 값이 비슷한 노드를 붙여야 한다.<br /> 삭제되는 노드와 가장 비슷한 노드는 왼쪽 서브트리의 가장 오른쪽 값과 오른쪽 서브트리의 가장 왼쪽 값이다. 책의 설명에 의하면 둘 중 어떤 것을 선택해도 상관 없으며 여기서는 오른쪽 서브트리의 값을 선택한다고 한다.<br /> 이어 붙일 노드를 정했다면 원래 있던 노드를 삭제한 자리로 옮기면 된다. 서브트리를 모두 옮기는 것이 아니고 단말 노드 하나만을 옮긴다.<br /> 이 과정을 수행하기 위해 삭제할 노드, 삭제 노드의 부모 노드, 후계자 노드, 후계자 노드의 부모 노드를 알아야 한다. 이중 후계 노드와 후계 노드의 부모 노드는 함수 내에서 탐색을 통해 찾을 수 있으므로 함수에는 삭제 노드와 삭제 노드의 부모 노드만 전달하면 된다.<br /> <br /> 세 가지 경우 모두 삭제 노드와 삭제 노드의 부모 노드만 알면 수행 가능하므로 하나의 함수로 구현하고 선택문을 두어 세 가지 경우를 구분하여 처리한다. 복수의 노드 정보를 필요로 하므로 노드 클래스에서 구현할 수는 없다.</p><p><br /></p><p><h2>이진 탐색 프로그램</h2>위에서 설계한 이진 트리 클래스를 종합하고 인스턴스를 생성하여 테스트해본다.</p><p><br /></p><p><h2>이진 탐색 트리의 성능 분석</h2>이진 탐색 트리의 시간 복잡도에 대해 설명하고 있다. 균형 트리에 대해 언급하였다.</p><p><br /></p><p><h2>이진 탐색 트리의 응용: 영어 사전</h2>꼭 영어 사전일 필요는 없다. 트리에 저장되는 레코드는 단어와 의미를 갖고, 단어는 공백이 없는 하나의 문자열, 의미는 여러 개의 단어로 이루어진 문자열이다.<br /> 사전의 기능은 입력, 삭제, 단어 탐색, 의미 탐색, 사전 출력, 종료로 구성된다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/satinbower/categories/it/'>IT</a>, <a href='/satinbower/categories/data-structure/'>Data Structure</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/satinbower/tags/%EC%A7%80%EC%8B%9D/" class="post-tag no-text-decoration" >지식</a> <a href="/satinbower/tags/it/" class="post-tag no-text-decoration" >IT</a> <a href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/" class="post-tag no-text-decoration" >자료구조</a> <a href="/satinbower/tags/%ED%8A%B8%EB%A6%AC/" class="post-tag no-text-decoration" >트리</a> <a href="/satinbower/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC/" class="post-tag no-text-decoration" >이진 탐색 트리</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko"> CC BY-NC-ND 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%5D+%EC%9D%B4%EC%A7%84+%ED%83%90%EC%83%89+%ED%8A%B8%EB%A6%AC+-+%EC%83%88%ED%8B%B4%EB%B0%94%EC%9A%B0%EC%96%B4&url=https%3A%2F%2Fdapin1490.github.io%2Fsatinbower%2Fposts%2Fit-data-structure-binary-search-tree%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/satinbower/posts/it-leetcode-230103/">[LeetCode][cpp, py] 944. Delete Columns to Make Sorted</a><li><a href="/satinbower/posts/chatgpt-230103/">Unity vs Unreal Engine</a><li><a href="/satinbower/posts/it-leetcode-221228/">[LeetCode][cpp] 1962. Remove Stones to Minimize the Total</a><li><a href="/satinbower/posts/it-leetcode-221230/">[LeetCode][cpp] 1. Two Sum</a><li><a href="/satinbower/posts/it-leetcode-230101/">[LeetCode][py] 290. Word Pattern</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower/tags/it/">IT</a> <a class="post-tag" href="/satinbower/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a> <a class="post-tag" href="/satinbower/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower/tags/leetcode/">LeetCode</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/satinbower/posts/it-data-structure-tree/"><div class="card-body"> <em class="small" data-ts="1662289500" data-df="YYYY-MM-DD" > 2022-09-04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 트리</h3><div class="text-muted small"><p> 참고자료 &amp;lt;C++로 쉽게 풀어쓴 자료구조&amp;gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 8 트리 트리의 개념 트리는 계층적인 자료구조. 인공지능 문제에서는 결정 트리에 사용됨. 용어 정리 노드(node) : 트리에 존재하는 각 지점들 ...</p></div></div></a></div><div class="card"> <a href="/satinbower/posts/it-bin-search-tree/"><div class="card-body"> <em class="small" data-ts="1663940100" data-df="YYYY-MM-DD" > 2022-09-23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] Big-O와 이진 탐색 트리</h3><div class="text-muted small"><p> 과제 아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다. 1. 스케줄링 문제에 접근하는 이진 탐색 트리 소개(필수) (-&amp;gt; 응답시간 대기시간 등등 말하는 것 같음. &quot;좋은 스케줄링은 프로세서의 효율성을 높이고, 프로세스의 응답시간을 최소화하여 시스템의 작업 처리 능력을 향상시킨다.&quot;) 2. Big-O 소개(선택) 3. 문...</p></div></div></a></div><div class="card"> <a href="/satinbower/posts/it-bst-rank/"><div class="card-body"> <em class="small" data-ts="1664463300" data-df="YYYY-MM-DD" > 2022-09-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 이진 탐색 트리 Rank</h3><div class="text-muted small"><p> 과제 아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다. 1. Data structures augmentation 코딩 - Rank 구현 - AVL tree 구현 2. AVL tree 정의 등 강의 내용 정리 *Geeks for geeks 참조하세요. https://www.geeksforgeeks.org/avl-tree-se...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/satinbower/posts/daily-220906/" class="btn btn-outline-primary" prompt="이전 글"><p>22.09.06 sunny after rain</p></a> <a href="/satinbower/posts/knowledge-SDG-2021/" class="btn btn-outline-primary" prompt="다음 글"><p>The Sustainable Development Goals Report 2021 주제 골라서 의견 쓰기</p></a></div><script src="https://utteranc.es/client.js" repo="dapin1490/satinbower" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dapin1490">dapin1490</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY-NC-ND 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower/tags/it/">IT</a> <a class="post-tag" href="/satinbower/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a> <a class="post-tag" href="/satinbower/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower/tags/leetcode/">LeetCode</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/satinbower/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/satinbower/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/satinbower/app.js"></script>
