<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="백트래킹" /><meta name="author" content="dapin1490" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="2580 스도쿠 미해결로 인해 풀이 대신 공부함 문제 참고(출처 : 백준) 15649 N과 M (1), 15650 N과 M (2), 15651 N과 M (3), 15652 N과 M (4) 9663 N-Queen, 2580 스도쿠 목차 - 재귀와 호출 스택 - 깊이 우선 탐색 - 백트래킹 재귀와 호출 스택 가볍게 “재귀”의 정의부터 읽어보고 시작하자. 출처는 네이버 사전이다." /><meta property="og:description" content="2580 스도쿠 미해결로 인해 풀이 대신 공부함 문제 참고(출처 : 백준) 15649 N과 M (1), 15650 N과 M (2), 15651 N과 M (3), 15652 N과 M (4) 9663 N-Queen, 2580 스도쿠 목차 - 재귀와 호출 스택 - 깊이 우선 탐색 - 백트래킹 재귀와 호출 스택 가볍게 “재귀”의 정의부터 읽어보고 시작하자. 출처는 네이버 사전이다." /><link rel="canonical" href="https://dapin1490.github.io/satinbower/posts/it-backtracking/" /><meta property="og:url" content="https://dapin1490.github.io/satinbower/posts/it-backtracking/" /><meta property="og:site_name" content="새틴바우어" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-29T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="백트래킹" /><meta name="twitter:site" content="@dapin1490" /><meta name="twitter:creator" content="@dapin1490" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dapin1490"},"dateModified":"2022-01-29T00:00:00+09:00","datePublished":"2022-01-29T00:00:00+09:00","description":"2580 스도쿠 미해결로 인해 풀이 대신 공부함 문제 참고(출처 : 백준) 15649 N과 M (1), 15650 N과 M (2), 15651 N과 M (3), 15652 N과 M (4) 9663 N-Queen, 2580 스도쿠 목차 - 재귀와 호출 스택 - 깊이 우선 탐색 - 백트래킹 재귀와 호출 스택 가볍게 “재귀”의 정의부터 읽어보고 시작하자. 출처는 네이버 사전이다.","headline":"백트래킹","mainEntityOfPage":{"@type":"WebPage","@id":"https://dapin1490.github.io/satinbower/posts/it-backtracking/"},"url":"https://dapin1490.github.io/satinbower/posts/it-backtracking/"}</script><title>백트래킹 | 새틴바우어</title><link rel="apple-touch-icon" sizes="180x180" href="/satinbower/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/satinbower/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/satinbower/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/satinbower/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/satinbower/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="새틴바우어"><meta name="application-name" content="새틴바우어"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/satinbower/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/satinbower/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/satinbower/" class="mx-auto"> <img src="/satinbower/assets/img/profile_image.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/satinbower/">새틴바우어</a></div><div class="site-subtitle font-italic">dapin1490's hand-made study blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/satinbower/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/satinbower/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/satinbower/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/satinbower/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/satinbower/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dapin1490" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dapin1490" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dapin1490','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/satinbower/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/satinbower/"> 홈 </a> </span> <span>백트래킹</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>백트래킹</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1643382000" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-01-29 </em> </span><div class="d-flex justify-content-between"> <span> By <em> dapin1490 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4649 단어"> <em>25 분</em>읽는 시간</span></div></div></div><div class="post-content"><h3 id="2580-스도쿠-미해결로-인해-풀이-대신-공부함"><span class="mr-2">2580 스도쿠 미해결로 인해 풀이 대신 공부함</span><a href="#2580-스도쿠-미해결로-인해-풀이-대신-공부함" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p><br /></p><h3 id="문제-참고출처--백준"><span class="mr-2">문제 참고(출처 : 백준)</span><a href="#문제-참고출처--백준" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>15649 N과 M (1), 15650 N과 M (2), 15651 N과 M (3), 15652 N과 M (4) <br /> 9663 N-Queen, 2580 스도쿠</p><p><br /><br /></p><h3 id="목차"><span class="mr-2">목차</span><a href="#목차" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>- 재귀와 호출 스택 <br /> - 깊이 우선 탐색 <br /> - 백트래킹</p><hr /><h3 id="재귀와-호출-스택"><span class="mr-2">재귀와 호출 스택</span><a href="#재귀와-호출-스택" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>가볍게 “재귀”의 정의부터 읽어보고 시작하자. 출처는 네이버 사전이다.</p><blockquote><p>재귀 再歸</p><ol><li>원래의 자리로 되돌아가거나 되돌아옴.<li>주어진 문제를 해결하기 위하여 하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 방식. 어떤 루틴이나 프러시저가 자기 자신을 반복적으로 호출하여 문제를 풀어 나가는 알고리즘으로, 이를 이용하기 위해서는 스택을 사용한다. 간단한 루틴을 풀 수 있지만, 처리 속도가 느리고 횟수가 지나치게 많으면 프로그램이 정지하기도 한다.</ol></blockquote><p>예상치 못하게 내가 할 설명을 네이버에게 뺏겼다. 하지만 저 말도 괜히 있어보이고 어렵게 생겼으니 내 특기인 없어보이지만 이해는 되는 말로 다시 설명하겠다.</p><p>재귀, 또는 재귀 함수라고 해도 된다. 함수가 자기 자신 내에서 스스로를 다시 호출하면 그것을 재귀 함수라고 부른다. 가볍게 활용해볼만한 예시로는 팩토리얼, 피보나치 수 등이 있다. 사람의 말로 길게 설명하는 것보다 예시 하나 보고 한 줄 한 줄 뜯어보는 게 훨씬 이해가 빠를 테니 내가 쓴 코드부터 보자.</p><p><br /><br /></p><p>문제 참고 : 백준 10872 팩토리얼 <br /> 깃허브 : <a href="https://github.com/dapin1490/hello-world/blob/main/cpp/10872%20%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC.cpp">C++ 소스 코드</a> <br /> 사용 언어 : C++ (파이썬과 자바는 아직 추가 계획이 없다)</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">fac</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// 팩토리얼 함수</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">fac</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// n이 1보다 작거나 같다면 1을 반환한다. n이 0일 때도 포함한다, 0! = 1이다.</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="c1">// n이 1보다 크다면 1이 될 때까지 (n - 1)로 다시 함수를 호출한다.</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>main() 부분에서는 딱히 볼 것이 없다. 입력을 받고 함수를 호출해 반환된 값을 출력하는 것뿐이다. 봐야 할 것은 함수에 쓰인 코드이다. <br /> 함수 내부는 크게 둘로 나뉜다. 인자로 전달된 n이 1 이하인 경우와 1을 초과하는 경우.</p><p>(1) n이 1 이하인 경우 <br /> 이 함수의 의미는 전달받은 정수의 팩토리얼 값을 계산하는 것이기 때문에 그 숫자가 0이거나 1이라면 계산할 필요가 없다. 어차피 답은 1이고 새삼스럽게 더 곱한다고 뭔가 대단한 1이 되지도 않는다.</p><p>(2) n이 1을 초과하는 경우 == n이 1보다 큰 경우 <br /> (1)의 경우와 달리 곱해야 할 수가 있는 상황이다. 하지만 지금 받은 수는 n 하나뿐이다. 이때 반복문을 쓰지 않고 할 수 있는 것이 재귀 호출이다. n을 알았다면 n보다 1 작은 수도 알 수 있다. 그러면 (n - 1)의 팩토리얼 값에 n을 곱하면 n!의 값을 알 수 있다. 다시 말해 n은 마지막에 숟가락만 얹을 테니 나머지 계산은 (n - 1)에게 미룬다는 것이다. n은 (n - 1)에게 계산을 미루고, 그 (n - 1)은 다음 호출에서 다시 n이 되어 또다른 (n - 1)에게 계산을 미룬다. 이 폭탄 돌리기의 현장에서 실제로 의미있는 값을 반환할 줄 아는 건 0과 1밖에 없다. 그러므로 재귀 호출은 n이 1보다 작거나 같아질 때까지 이어진다. 나는 이 값(1 또는 0)을 반환점이라고 부른다. 실제로 학계에서 의미가 있는 말인지는 모르겠다만, 내 편의상 그렇게 부르고 있다.</p><p>내가 1을 반환점이라고 부르는 것은 이유가 있다. 지금까지 빚처럼 쌓여만 오던 함수 호출을 청산하기 시작하는 지점이기 때문이다. 계속 n이라고만 하면 헷갈리니까 가볍게 4!을 구한다고 생각하고 그 과정을 따라가 보자.</p><ol><li>먼저 사용자는 4!의 값을 받기 위해 fac(4)를 호출한다.<li>함수 내부에서 4는 1보다 크기 때문에 else로 넘어가 4 * fac(3)을 반환한다. 이때 fac(3)의 값은 모르는 상태이기 때문에 프로그램은 결과를 반환하기 전에 fac(3)를 호출한다.<li>fac(3)가 호출되었기 때문에 이번에도 else로 넘어간다. fac(3)은 3 * fac(2)를 반환하고 싶다. 하지만 fac(2)의 값을 모른다. 그러니 다시 호출한다.<li>fac(2)는 2 * fac(1)을 반환하고 싶다. 하지만 fac(2)는 fac(1)의 값을 모른다. 재차 호출한다.<li>fac(1)은 자신의 값을 안다. 1을 반환한다.<li>방금 호출이 왔던 2 * fac(1)로 돌아간다. 값을 알아냈으니 2 * 1인 2를 반환한다.<li>3 * fac(2)로 돌아간다. 3 * 2인 6을 반환한다.<li>4 * fac(3)으로 돌아간다. 4 * 6인 24를 반환한다. 이 값은 사용자에게 전달된다.</ol><p>줄줄이 이어지는 함수 호출은 n이 1이 되어서야 끝을 맺고 지금껏 지나온 모든 호출들을 청산했다. 이 과정까지는 이제 무슨 말인지 알 수 있다. 하지만 의문이 남는다. 함수가 한 차례 끝나기도 전에 다시 호출하면 이전의 값들은 어떻게 알고 그 값을 그대로 되돌려주는가?</p><p>혹시 모르니 스택에 대해 잠깐 알아보고 가자. 이 글의 주요 개념은 아니니 깊이 알 건 없고, 프링글스 통이라고 생각하면 된다. 감자칩이 약간의 틈을 두고 켜켜이 쌓인 프링글스 통의 과자를 먹으려면 위에서부터 하나씩 집어먹어야 한다. 맨 아래에 있는 과자를 먼저 꺼내먹으라고 만든 구조는 당연히 아니다. 스택도 이와 비슷하다. 어떤 값들이 차례로 저장되어 들어오고, 사용자는 필요할 때 그것을 다시 꺼내 쓴다. 이때 마지막으로 들어온 데이터가 가장 먼저 꺼내진다. 지금 알아야 할 스택의 개념은 이 정도면 됐다. 앞으로 설명할 호출 스택이란 프로그램을 실행하면서 쌓인 함수 호출 등을 저장하는 스택인 것이다.</p><p><em>(이 문단의 내용은 내가 어떠한 자료를 참고하여 공부한 것이 아니고 디버깅 중 호출 스택을 보며 알아낸 것이기 때문에 부족하거나 부적절한 내용이 있을 수 있다. 만약 있다면 알려주길 바란다.)</em> 함수의 호출은 우리가 생각하는 것처럼 단편적이거나 평면적인 과정이 아니다. 모든 완료되지 않은 호출은 ‘호출 스택’이라는 것에 저장된다. 컴파일러마다 화면이 다르니 정확히 어디서 확인할 수 있는지는 알려줄 수 없다. 대신 내가 쓰는 비주얼 스튜디오 화면[이미지 1]을 보여줄 테니 참고하자. 캡쳐한 시점은 입력 값으로 4를 입력해 fac(4)가 호출되고 재귀를 거쳐 fac(1)에서 1이 반환되기 직전이다. 빨간 선으로 조금 구겨진 네모가 쳐진 곳이 호출 스택이 나타나는 부분이다. 호출 스택에 보이는 것은 호출이 온 줄의 번호 뿐이지만 호출된 순간의 변수 상태도 같이 저장된다. 그렇기 때문에 함수 내에서 자기 자신을 재차 호출해도 앞선 호출에 저장된 값을 덮어쓰지 않는다. 나는 이걸 몰라서 재귀함수에 대해 한참을 이해하지 못하고 있었다.</p><figure style="text-align:center"> <img data-src="/satinbower/assets/img/category-it/220129-1-call-stack.png" data-proofer-ignore><figcaption>[이미지 1] 재귀 함수 fac(4) 호출 스택</figcaption></figure><p><br /><br /></p><h3 id="--깊이-우선-탐색"><span class="mr-2">- 깊이 우선 탐색</span><a href="#--깊이-우선-탐색" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>백트래킹에 대해 배우려면 먼저 깊이 우선 탐색이라는 것을 알아야 한다. 이것도 개념만 놓고 본다면 그리 어렵지 않다. 가볍게 ‘탐색’에 대해서부터 알아보자. 어떠한 알고리즘을 이용해 원하는 값을 찾는 것과 그 방법 등을 크게 일러 탐색이라고 한다. 그 종류는 꽤나 다양한데 단순히 원하는 값이 나올 때까지 모든 값을 하나씩 까보는 방법도 있고, 여러 갈래로 갈라지는 분기를 하나씩 들러 찾아보는 방법도 있다. 이중 깊이 우선 탐색은 여러 갈래로 갈라지는 분기를 앞에서부터 하나씩, 끝까지 가보고 원하는 값인지 아닌지 판단하는 방법이다. 자매품으로 너비 우선 탐색이 있는데, 이 방법은 갈 수 있는 분기를 모두 하나씩 들러보면서 내려간다. 둘 모두 주로 트리나 그래프라는 자료구조에서 활용한다. 그래프라는 것은 수학에서 사용하는 x 축과 y 축이 있는 그것은 아니고, 쾨니히스베르크의 다리를 검색하면 나오는 이미지 같은 것을 말한다.</p><p>깊이 우선 탐색에 대해 조금 더 알아보자. 한빛 아카데미 출판, &lt;소프트웨어 세상을 여는 컴퓨터 과학&gt;에 의하면 깊이 우선 탐색은 “시작 정점에서 시작하여 그 정점과 연결된 방문하지 않은 한 정점을 방문하고, 다음에는 방문한 정점에서 다시 연결된 방문하지 않은 한 정점 순으로 방문한다. 진행하다가 더 이상 진행할 수 없으면 왔던 길을 되돌아가면서 아직 방문하지 않은 한 정점을 방문한다.”라고 한다.</p><p>예를 들어 보자. 여기 1부터 3까지의 자연수가 있다. 사용자는 중복 없이 사전 순으로 이 수들을 두 개씩 뽑아 짝을 짓고 싶다. 이때 사용할 수 있는 방법이 깊이 우선 탐색이고, 여기에 백트래킹도 포함된다. 일단은 깊이 우선 탐색만 생각해보자.</p><ol><li>가장 먼저 1을 하나 뽑는다.<li>1의 짝으로 올 수 있는 숫자는 2, 3이 있다. 먼저 2를 뽑아 하나의 짝을 완성한다. → (1, 2)<li>다시 1을 하나 뽑는다.<li>이번에 1의 짝으로 올 수 있는 숫자는 3뿐이다. → (1, 3)<li>1로 만들 수 있는 짝은 다 만들었으니 이번에는 2를 뽑는다.<li>2의 짝으로 올 수 있는 숫자는 1과 3이다. 1을 먼저 뽑는다. → (2, 1)<li>이후의 과정은 생략한다. → (2, 3), (3, 1), (3, 2)</ol><p>간단하고 빠른 설명을 위해 소박한 예시를 들어 깊이라는 말이 잘 체감되지 않을 수 있다. 좀 더 예시가 필요하다면 위의 예시에서 숫자를 더 크게 잡아보거나 스스로 그럴싸한 예시를 고민해 보자. 직접 문제를 만들어보는 것도 공부에 도움된다.</p><p><br /><br /></p><h3 id="--백트래킹"><span class="mr-2">- 백트래킹</span><a href="#--백트래킹" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>백트래킹은 깊이 우선 탐색의 개정판 같은 것이다. 앞서 알아본 깊이 우선 탐색은 답을 찾기 위해 전진만 할 줄 알았지, 지금 가는 길이 답이 아니라는 것을 알았을 때 되돌아갈 줄은 몰랐다. 백트래킹은 깊이 우선 탐색이 뒷걸음질을 치게 만드는 알고리즘이다. 참고할만한 문제는 글의 서두에 적어두었으니 다른 사람의 풀이를 찾아봐도 좋고 혼자 도전해도 좋으니 한번 풀어보자. 나도 보고 배웠으니 여기서 풀이할 마음 없다.</p><p>비교하기 좋게 예시를 재활용하자. 숫자가 너무 적으면 결과도 적으니 이번엔 1부터 4까지의 자연수를 중복 없이, 오름차순으로 2개씩 뽑아보겠다. 당연히 사전순으로 뽑는다.</p><ol><li>1을 뽑는다.<li>1의 짝으로 올 수 있는 수는 2, 3, 4이다. 2를 먼저 뽑는다. → (1, 2)<li>뽑았던 2를 <strong>도로 내려놓고</strong> 다른 수를 뽑는다. 남은 것은 3과 4이니 3을 뽑는다. → (1, 3)<li>3을 <strong>도로 내려놓고</strong> 다른 수를 뽑는다. 4가 남았다. → (1, 4)<li>4를 <strong>내려놓고</strong> 나니 1의 짝으로 남은 수가 없다. 1도 <strong>내려놓는다</strong>.<li>1은 끝났으니 2를 뽑는다.<li>1은 2보다 작으니 치워놓고, 2의 짝으로 가능한 수는 3, 4이다. 3을 뽑는다. → (2, 3)<li>3을 <strong>내려놓고</strong> 남은 수는 4이다. → (2, 4)<li>4를 <strong>내려놓고</strong> 나면 남은 수가 없다. 2도 <strong>내려놓는다</strong>.<li>이하 생략 → (3, 4)</ol><p>이 알고리즘에서 핵심적인 역할을 하는 것이 재귀 호출이다. 숫자 하나를 뽑아 놓은 상태에서 숫자를 뽑는 함수를 재차 호출해 다음 수를 뽑는다. 뽑기가 끝나면 결과를 출력하고 뽑은 수를 돌려놓는다. 호출이 끝나 돌아올 때는 해당 줄로 똑같이 되돌아와서 그 다음 줄을 바로 실행하기 때문에 재귀 호출이 있는 부분 위에서는 수를 뽑고, 재귀 호출 아래에서 뽑은 수를 돌려놓는 코드를 쓰면 위와 같은 과정이 가능하다. 문제를 풀이할 생각은 없다고 했지만 아무래도 예시가 없으면 아쉬우니 조금만 보자. 15650 N과 M (2) 문제에 사용한 함수이다.</p><p>사용 언어 : C++, 파이썬 <br /> 파이썬 코드 : [<a href="https://github.com/dapin1490/hello-world/blob/main/python/15650%20N%EA%B3%BC%20M%20(2).py">파이썬 소스 코드</a>] <br /> [<a href="https://github.com/dapin1490/hello-world/blob/main/cpp/15650%20N%EA%B3%BC%20M%20(2).cpp">C++ 소스 코드</a> 일부]</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">pr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="c1">// n개의 수 중에서 중복 없이 오름차순으로 m개의 수를 뽑음</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span> <span class="c1">// 필요한 만큼 수를 뽑았을 때 실행</span>
    <span class="p">{</span>
        <span class="c1">// 뽑은 수를 출력한다.</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// 실행이 끝나고 이전 호출로 되돌아간다.</span>
    <span class="p">}</span>

    <span class="c1">// 아직 수를 충분히 뽑지 못했을 때</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 숫자의 총 개수만큼 반복 : 첫 번째 숫자부터 끝까지 하나씩 조건에 맞는지 시도해본다</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nvi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">)</span> <span class="c1">// 이미 뽑은 숫자이거나 직전에 뽑은 숫자보다 작은 숫자일 경우</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// 숫자를 뽑지 않고 넘긴다</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 넘기지 않았다면 숫자를 뽑는다.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 오름차순으로 하기 위해 지금 뽑은 숫자를 기록한다.</span>
        <span class="n">nvi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 중복 방지를 위해 뽑았다는 것도 표시해 둔다.</span>
        <span class="n">pr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span> <span class="c1">// 재귀 호출</span>
        <span class="n">v</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">// 호출에서 되돌아왔을 때 실행한다. 뽑은 숫자를 하나 버린다.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 기록한 숫자를 지운다.</span>
        <span class="n">nvi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 뽑았다는 표시도 지운다.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>내가 이 알고리즘이 어려웠던 이유는 재귀호출 이후 되돌아올 때 이전의 변수 상태까지 같이 되돌아간다는 것을 알지 못했기 때문이었다. 지금은 그건 알지만 그냥 문제가 어렵다.. 이론을 아는 것과 활용이 되는 건 꽤 다른 문제다.</p><p>숫자 뽑기 예시에서는 뽑아둔 숫자를 다 사용한 후 다시 버리기 위해 재귀 호출 뒤의 코드에 숫자를 지우는 부분이 들어갔지만 굳이 그런 과정이 필요 없는 경우에는 return;을 쓰기도 한다. 그리고 재귀를 설명할 때 내가 “반환점”을 언급한 적이 있는데, 꼭 모든 재귀 함수와 백트래킹이 반환점을 돌아서 가지는 않는다. 일례로 9663 N-Queen 문제는 함수에 전달하는 첫 인자로 0을 넘긴다고 풀이한다. n에서부터 0까지 가는 과정이 필요하지 않기 때문에 하지 않는 것이라고 본다. 2580 스도쿠 문제도 비슷하게 시작하지만, 아직까지는 그 풀이를 이해하지 못하기도 했고, 내가 쓴 풀이에 미련이 남아 더이상 진행할 수가 없다. 내 풀이를 잊을 때까지 시간이 좀 필요하다..</p><p><br /><br /></p><p>참고 도서 <br /> &lt;소프트웨어 세상을 여는 컴퓨터 과학&gt;, 김종훈 지음, 한빛 아카데미 출판</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/satinbower/categories/it/'>IT</a>, <a href='/satinbower/categories/algorithm/'>Algorithm</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/satinbower/tags/%EC%A7%80%EC%8B%9D/" class="post-tag no-text-decoration" >지식</a> <a href="/satinbower/tags/it/" class="post-tag no-text-decoration" >IT</a> <a href="/satinbower/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/" class="post-tag no-text-decoration" >백트래킹</a> <a href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" class="post-tag no-text-decoration" >알고리즘</a> <a href="/satinbower/tags/%EC%9E%AC%EA%B7%80/" class="post-tag no-text-decoration" >재귀</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko"> CC BY-NC-ND 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9+-+%EC%83%88%ED%8B%B4%EB%B0%94%EC%9A%B0%EC%96%B4&url=https%3A%2F%2Fdapin1490.github.io%2Fsatinbower%2Fposts%2Fit-backtracking%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/satinbower/posts/it-leetcode-230103/">[LeetCode][cpp, py] 944. Delete Columns to Make Sorted</a><li><a href="/satinbower/posts/chatgpt-230103/">Unity vs Unreal Engine</a><li><a href="/satinbower/posts/it-leetcode-221228/">[LeetCode][cpp] 1962. Remove Stones to Minimize the Total</a><li><a href="/satinbower/posts/it-leetcode-221230/">[LeetCode][cpp] 1. Two Sum</a><li><a href="/satinbower/posts/it-leetcode-230101/">[LeetCode][py] 290. Word Pattern</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower/tags/it/">IT</a> <a class="post-tag" href="/satinbower/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a> <a class="post-tag" href="/satinbower/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower/tags/leetcode/">LeetCode</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/satinbower/posts/it-counting-sort/"><div class="card-body"> <em class="small" data-ts="1643382000" data-df="YYYY-MM-DD" > 2022-01-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>카운팅 정렬(+ 선택 정렬)</h3><div class="text-muted small"><p> 이 수는 몇 개 있으니까 여기 놓고 저 수는 몇 개 있으니까 저기 놓고… 더보기 많고 많은 정렬 알고리즘 중 정렬할 수의 범위가 한정적일 때 쓸 수 있는 카운팅 정렬을 공부해 보자. 선택 정렬은 덤이다. 1. 정렬 알고리즘 위키백과에 따르면 ‘원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘’이라고 한다. 선택 정렬...</p></div></div></a></div><div class="card"> <a href="/satinbower/posts/it-quick-sort/"><div class="card-body"> <em class="small" data-ts="1644073200" data-df="YYYY-MM-DD" > 2022-02-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>퀵 정렬</h3><div class="text-muted small"><p> 올림피우스는 결승점의 절반을 가고, 그 나머지 절반의 절반을 가고, 또 그 절반을 가고… 더보기 데이터를 빠르게 반으로 갈라버리는 퀵 정렬을 배워보자. 부제목에 쓰인 이야기는 제논의 역설 중 하나이다. ‘아킬레우스와 거북이의 경주’도 있는데 재밌으니 한번 찾아보자. - 알아야 할 것 0. 재귀 → 백트래킹 1. 분할 정복 2. 퀵 정렬 ...</p></div></div></a></div><div class="card"> <a href="/satinbower/posts/it-kadane-algorithm/"><div class="card-body"> <em class="small" data-ts="1652799600" data-df="YYYY-MM-DD" > 2022-05-18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>카데인 알고리즘</h3><div class="text-muted small"><p> 뭐 별 게 다 있어.. 프로그래머란 대체 자 생각을 해보자. 어떤 배열에서 연속한 원소로 이루어진 부분 배열의 합의 최댓값을 찾고 싶다. 그런데 시간이 별로 없다. 이럴 때 쓰는 게 카데인 알고리즘이다. 이중 반복문으로 답을 찾는 브루트포스는 시간복잡도가 O(n²)이지만 이 알고리즘은 O(n)이다. 목차 1. 동적 계획법 2. 카데인 알...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/satinbower/posts/it-deep-learning/" class="btn btn-outline-primary" prompt="이전 글"><p>딥러닝의 탄생과 활용</p></a> <a href="/satinbower/posts/it-counting-sort/" class="btn btn-outline-primary" prompt="다음 글"><p>카운팅 정렬(+ 선택 정렬)</p></a></div><script src="https://utteranc.es/client.js" repo="dapin1490/satinbower" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dapin1490">dapin1490</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY-NC-ND 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower/tags/it/">IT</a> <a class="post-tag" href="/satinbower/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a> <a class="post-tag" href="/satinbower/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower/tags/leetcode/">LeetCode</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/satinbower/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/satinbower/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/satinbower/app.js"></script>
